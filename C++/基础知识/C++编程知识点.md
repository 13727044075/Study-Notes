# C++编程知识点

标签（空格分隔）： C++

---

这里总结一些在进行C++编程练习中需要记录的知识点。

#### 1. 指针和引用
##### 1）两个指针之间的运算

**只有指向同一个数组的两个指针变量之间才能进行运算，否则运算毫无意义**。

(1) 指针变量的相减

**两指针变量相减所得之差是两个指针所指数组元素之间相差的元素个数，实际上是两个指针值(地址)相减之差再除以该数组元素的长度(字节数).**

例如pf1和pf2是指向同一浮点数组的两个指针变量，设pf1的值为2010H，pf2的值为2000H，而浮点数组每个元素占4个字节，所以pf1-pf2的结果为(2000H-2010H)/4=4，表示pf1和 pf2之间相差4个元素。

> 注意：两个指针变量不能进行加法运算。例如，pf1+pf2是什么意思呢？毫无实际意义。

(2) 两指针变量进行关系运算
**指向同一数组的两指针变量进行关系运算可表示它们所指数组元素之间的关系**。例如：

- pf1 = pf2 表示pf1和pf2指向同一数组元素； 
- pf1 > pf2  表示pf1处于高地址位置； 
- pf1 < pf2  表示pf2处于低地址位置。

指针变量还可以与0比较。设p为指针变量，则p==0表明p是空指针，它不指向任何变量；p!=0表示p不是空指针。 

空指针是由对指针变量赋予0值而得到的。例如：
```
#define NULL 0
int *p = NULL;
```
对指针变量赋0值和不赋值是不同的。**指针变量未赋值时，值是随机的，是垃圾值，不能使用的，否则将造成意外错误。而指针变量赋0值后，则可以使用，只是它不指向具体的变量而已。**

##### 2） 常量指针和指针常量

* const在\*的左测，指针所指向的内容不可变，即**\*p不可变**
* const在\*的右侧，**指针不可变，即p++不被允许**；

**const 限定一个对象为只读属性。** 
先从一级指针说起吧： 
（1）const char p    限定变量p为只读。这样如p=2这样的赋值操作就是错误的。 
（2）const char \*p   p为一个指向char类型的指针，const只限定p指向的对象为只读。这样，p=&a或  p++等操作都是合法的，但如\*p=4这样的操作就错了，因为企图改写这个已经被限定为只读属性的对象。 
（3）char \*const p  限定此指针为只读，这样p=&a或  p++等操作都是不合法的。而\*p=3这样的操作合法，因为并没有限定其最终对象为只读。 
（4）const char \*const p 两者皆限定为只读，不能改写。 
有了以上的对比，再来看二级指针问题： 
（1）const char \**p  p为一个指向指针的指针，const限定其最终对象为只读，显然这最终对象也是为char类型的变量。故像\**p=3这样的赋值是错误的，而像*p=？ p++这样的操作合法。 
（2）const char \* const \*p 限定最终对象和 p指向的指针为只读。这样 *p=?的操作也是错的。 
（3）const char \* const \* const p 全部限定为只读，都不可以改写。

##### 3）指针数组和数组指针

* 区分int \*p[n]; 和int (\*p)[n];就要看**运算符的优先级**了。

  int \*p[n]; 中，运算符[]优先级高，先与p结合成为一个数组，再由int\*说明这是一个整型指针数组。

  int (\*p)[n]; 中()优先级高，首先说明p是一个指针，指向一个整型的一维数组。

  例子：
  int \*s[8]; //定义一个指针数组，该数组中每个元素是一个指针，每个指针指向哪里就需要程序中后续再定义了。 

  int (\*s)[8]; //定义一个数组指针，该指针指向含8个元素的一维数组（数组中每个元素是int型）。

* 对于一个数组，如`int a[10];`，对其数组名进行加减，如果有取地址符和没有是有区别的：

  ```c++
  // 有取地址符，相当于每次增加整个数组的长度的倍数
  &a + i = a + i*sizeof(a);
  // 没有使用取地址符，只是数组名，则增加数组中元素的长度的倍数
  a + i = a + i*sizeof(a[0]);
  ```

##### 4）引用

* 引用是变量的别名，在声明的时候就必须初始化
* 引用传递**不可以改变原变量的地址**，但**可以改变原变量的内容**


----------
#### 2. 类和函数
##### 1） 虚函数

* **声明纯虚函数的类是抽象类，不能实例化**

* **基类被虚继承才是虚基类**

* **virtual 函数是动态绑定，而缺省参数值却是静态绑定。** 意思是你可能会 **在“调用一个定义于派生类内的virtual函数”的同时，却使用基类为它所指定的缺省参数值。**

  结论：**绝不重新定义继承而来的缺省参数值！**（可参考《Effective C++》**条款37**）

* 基类的成员函数设为`virtual`，其派生类的相应的函数也会**自动变为虚函数**。

* 由于类的构造次序是由基类到派生类，所以**在构造函数中调用虚函数，这个虚函数不会呈现出多态**； 相反，类的**析构是从派生类到基类**，当调用继承层次中某一层次的类的析构函数时往往意味着其派生类部分已经析构掉，所以也**不会呈现出多态**

* **静态函数不可以是虚函数**

  因为静态成员函数没有this，也就没有存放vptr的地方，同时其函数的指针存放也不同于一般的成员函数，其无法成为一个对象的虚函数的指针以实现由此带来的动态机制。静态是编译时期就必须确定的，虚函数是运行时期确定的。

* **内联函数不能为虚函数**；但虚函数可以声明为`inline`，只是编译器会忽略`inline`属性。

* **构造函数，静态成员函数，友元函数都不能是虚函数**；只有类的成员函数才能说明虚函数；析构函数可以是虚函数，而且通常声明为虚函数，**它可以保证释放父类指针时能正确释放子类对象**。

##### 2） 组合和继承

**“优先使用对象组合，而不是继承”**是面向对象设计的第二原则。

组合也叫“对象持有”，就是在类中定义另一类型的成员，**继承会破坏类的独立性**，增加系统的复杂性，一般系统的继承层次不超过3层。组合拥有良好的扩展性，支持动态组合，因此请优先考虑组合方法。

##### 3） 子类型
* 子类型必须是子类继承了父类的所有可继承特性，也即**公有继承**，才能说是子类型，否则就只是单纯的子类
* 一种类型当它至少提供了另一种类型的行为,则这种类型是另一种类型的子类型
* 子类型关系是不可逆的

##### 4） 内联函数

* **内联函数只适合于只有1～5行的小函数。**对一个含有许多语句的大函数，函数调用和返回的开销 相对来说微不足道，所以也没有必要用内联函数实现。
* 在内联函数内不允许用循环语句和开关语句。否则编译将该函数视同普通函数。
* 如果内联函数定义在调用函数的后面，则编译器会将其当作普通函数调用来看，**并不会直接插入到调用处**

##### 5） 静态变量

* 通常静态数据成员在类声明中声明,在包含类方法的文件中初始化.
* 初始化时使用**作用域操作符来指出静态成员所属的类.**
* 但如果**静态成员是整型或是枚举型const,则可以在类声明中初始化**
* **静态局部变量存在静态存储区**，而局部变量存储在堆栈区，确切的说是**栈区**
* 静态局部变量有以下特点： 
      （1）该变量在全局数据区分配内存；
      （2）静态局部变量在程序执行到该对象的声明处时被**首次初始化**，即**以后的函数调用不再进行初始化**；
      （3）静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；
      （4）它始终驻留在**全局数据区，直到程序运行结束。但其作用域为局部作用域，**当定义它的函数或语句块结束时，其作用域随之结束；
* **函数中的静态变量是静态局部变量 ，函数退出后不被释放，在程序运行结束时才释放。只在函数中可访问。**
* **静态全局变量的作用域只能是定义它的文件里，不是被其他文件使用。**
* **类的静态成员属于整个类**，而不是某个对象，**可以被类的所有方法访问**，**子类也可以访问父类的静态成员**；
* **所有静态方法只能访问静态成员，不能访问非静态成员，**因为静态方法属于整个类，在对象创建之前就已经分配空间，类的非静态成员要在对象创建后才有内存；
* **静态成员可以被任一对象修改，修改后的值可以被所有对象共享**。


##### 6） 函数
* **可变参数函数需要由调用者清栈**，因为当前函数并不知道要有多少参数被传入，所以必须用**cdcel**

* 函数重载是面向对象程序设计的多态性的实现，就是指**同一个函数名**对应着不同的函数实现，系统可根据**参数的类型、个数来**自动完成调用函数的最佳匹配。

  重载函数的参数至少要有一方面不同，表现如下：

  1.函数的**参数类型和个数不同**；

  2.函数**参数的顺序不同**。如：`fun(double,int)`和`fun(int,double)`就是两个不同的函数

  重载的函数是在**相同的范围，即同一个类中**，对于`virtual`关键字是可有可无。

* **覆盖**是指派生类函数覆盖基类函数，特征是：

  1. 不同的范围，分别位于派生类和基类；
  2. 函数名字相同；
  3. 参数相同；
  4. **基类函数必须有`virtual`关键字。**

* **隐藏**是指派生类的函数屏蔽了同名的基类函数，规则如下：

  1. 如果派生类的函数与基类的**函数同名，但是参数不同。此时，不论有无virtual关键字**，基类的函数将被隐藏（注意别与重载混淆）。
  2. 如果派生类的函数与基类的**函数同名，并且参数也相同，但是基类函数没有virtual 关键字**。此时，基类的函数被隐藏（注意别与覆盖混淆）

* 当函数返回值之后，其函数内部的**栈空间均会被销毁**；在函数内部，若程序员没有为指针分配空间，则函数退出时，其栈空间也就不存在了；因此，**使用数组时，不能返回一个数组**；

* 函数不能嵌套定义，也就是函数内部不能定义函数。

* 如果在类的析构函数中调用`delete this`，会发生什么？实验告诉我们，会导致堆栈溢出。原因很简单，`delete`的本质是**“为将被释放的内存调用一个或多个析构函数，然后，释放内存”**。显然，**`delete this`会去调用本对象的析构函数，而析构函数中又调用`delete this`，形成无限递归，造成堆栈溢出，系统崩溃。**

* 不建议在构造函数中抛出异常，构造函数抛出异常时，析构函数不会执行，需要手动的去释放内存；

* 构造函数的调用顺序与析构函数的调用顺序相反，这是因为是使用栈实现，先进后出。

* 析构函数不应该抛出异常；当析构函数中会有一些可能发生异常时，那么就必须把这种可能发生的异常完全封装在析构函数内部，决不能让它抛出函数之外。

* 当派生类中不含对象成员时

  · **在创建派生类对象时,构造函数的执行顺序是：基类的构造函数→派生类的构造函数；**

  **· 在撤消派生类对象时,析构函数的执行顺序是：派生类的构造函数→基类的构造函数。**

  当派生类中含有对象成员时

  · **在定义派生类对象时，构造函数的执行顺序：基类的构造函数→对象成员的构造函数→派生类的构造函数；**

  **· 在撤消派生类对象时，析构函数的执行顺序：派生类的构造函数→对象成员的构造函数→基类的构造函数。**

* 对于只做输入的参数：

  a) 始终用const限制所有指向只输入参数的指针和引用。

  b) 优先通过值来取得**原始类型和复制开销比较低的值的对象**。

  c) 优先按const的引用取得其他用户定义类型的输入。

  d) 如果函数需要其参数的副本，则可以考虑通过值传递代替通过引用传递

##### 7） 继承和访问
（1）基类的私有成员无论什么继承方式，在派生类中均不可以直接访问

（2）在公有继承下，基类的保护成员和公有成员均保持原访问属性

（3）在保护继承方式下，基类的保护和公有成员在派生类的访问属性均为保护属性

（4）在私有继承下，基类的保护和公有成员在派生类中的访问属性均为私有属性

##### 8）初始化列表

一定需要初始化列表的有三种成员：

* 带有`const`修饰的类成员，如`const int a;`

* 引用成员，如`int &p;`

* 带有引用的类变量，如

  ```c++
  class A{
    private:
    	int &a;
  };
  class B{
    private:
    	A c;
  };
  // 这里类B的成员c就需要初始化列表进行初始化。
  ```
  此外，对于`static`成员是不允许在类内初始化的，而`static const`成员也不能使用初始化列表。

* 如果父类中没有默认构造方法，那么，在**子类中的初始化列表中必须显式的调用基类的有参数构造**，否则会编译不通过

##### 9） 多态

* 重载多态和强制多态是 指**特定多态**。
* 参数多态和包含多态是指**通用多态**。包含多态是指对基类的**virtual**函数进行重写。

##### 10）运算符

* 只能使用成员函数重载的运算符有：**=、()、[]、->、new、delete**。
* **单目运算符**最好重载为成员函数。
* 对于复合的赋值运算符如**+=、-=、*=、/=、&=、!=、~=、%=、>>=、<<=**建议重载为成员函数。
* 对于其它运算符，**建议重载为友元函数**。

运算符重载的方法是定义一个重载运算符的函数，在需要执行被重载的运算符时，系统就自动调用该函数，以实现相应的运算。也就是说，运算符重载是通过定义函数实现的。**运算符重载实质上是函数的重载**。重载运算符的函数一般格式如下：

```c++
函数类型 operator 运算符名称 (形参表列){ 
    // 对运算符的重载处理
}
```

* 重载为类成员函数时参数个数=原操作数个数-1（后置++、--除外）

* 重载为友元函数时 参数个数=原操作数个数，且至少应该有一个自定义类型的形参

* 不能重载的运算符有：**.（点号），::（域解析符），?:（条件语句运算符），sizeof（求字节运算符），typeid，static_cast，dynamic_cast，interpret_cast（三类类型转换符）**

* **逗号运算符：**在C语言中，多个表达式可以用逗号分开，其中用逗号分开的表达式的值分别结算，**但整个表达式的值是最后一个表达式的值。**

  ​

##### 11） 抽象类

抽象类是不完整的，它只能用作基类。在面向对象方法中，抽象类主要用来进行类型隐藏和充当全局变量的角色。

- **抽象类不能实例化**。
- 抽象类可以包含抽象方法和抽象访问器。
- 不能用` sealed `修饰符修饰抽象类，因为这两个修饰符的含义是相反的。 采用 `sealed` 修饰符的类无法继承，而` abstract` 修饰符要求对类进行继承。
- 从抽象类派生的非抽象类必须包括继承的所有抽象方法和抽象访问器的实际实现。

----------
#### 3. C语言知识点
##### 1） 标识符

**C语言中的标识符有：关键字，预定义标识符，用户标识符。**

##### 2） C结构体之位域(位段)

参考文章[C结构体之位域(位段)][1]

##### 3）柔性数组 

**柔性数组(Flexible Array)**也叫伸缩性数组，也就是**变长数组**，反映了C语言对精炼代码的极致追求。

这种代码结构产生于对动态结构体的需求， 比如我们需要在结构体中存放一个动态长度的字符串时，就可以用柔性数组。

C99使用不完整类型来实现柔性数组，标准形式如下：

```c++
struct MyStruct{
  int a;
  double b;
  char c[];	// or char c[0]; 也可以用其他数据类型
}
```
上述结构体中的**`c`不占用`MyStruct`的空间，只是作为一个符号地址存在，而且必须是结构体的最后一个成员。**

参考文章：[柔性数组-读《深度探索C++对象模型》有感](http://www.cnblogs.com/nchxmoon/p/3145480.html)

----------
#### 4. 线程安全
##### 1） 定义

* **线程安全**就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。

* **线程不安全**就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据

##### 2） 概念

* 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。
* 或者说:一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。
* **线程安全问题都是由全局变量及静态变量引起的。**
* **若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；**若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。
* 标准库里面的string在**多线程下并不保证是都是安全的**，只提供两种安全机制：
    1.多个线程同时读取数据是安全的。
    2.只有一个线程在写数据是安全的。
* **局部变量局部使用是安全的。因为每个thread都有自己的运行堆栈，而局部变量是生存在堆栈中,大家不干扰。**
* 全局原生变量多线程读写是不安全的，全局变量是在堆(heap)中。
* 函数静态变量多线程读写也是不安全的。
* volatile能保证全局整形变量是多线程安全的么？不能。volatile仅仅是告诫compiler不要对这个变量作优化，每次都要从memory取数值，而不是从register
* InterlockedIncrement保证整型变量自增的原子性。
* POSIX线程标准要求C标准库中的大多数函数具备线程安全性
* **写好多线程安全的法宝就是封装，使数据有保护的被访问到** 
* **安全性：局部变量 > 成员变量 > 全局变量**


##### 3） 多线程

* 实现一个多线程(非MFC)程序, 选择多线程CRT, 创建线程的时候应该用

  **_beginthreadex()**，因为**_beginthreadex()**比较于 **CreateThread()**有更高的**线程安全性**，不会造成**多个线程共用同一个全局变量**的情况

##### 4）线程同步
（1） 进程间通信方法有：文件映射、共享内存、匿名管道、命名管道、邮件槽、剪切板、动态数据交换、对象连接与嵌入、动态连接库、远程过程调用等
（2） **事件、临界区、互斥量、信号量可以实现线程同步**

----------
#### 5. 其他
##### 1）宏定义

C/C++中，**宏定义只是做简单的字符替换。**

例如：在 `#define add(a,b) a+b` 中，`a+b`没有括号，所以 `3*add(4,7)`实际的替换情况是：`3*4+7=19`；若`a+b`有括号，`#define add(a,b) （a+b）`则结果为：`3*（4+7）=33`；

**typedef**作用是给已存在的数据类型引入一个**别名**，语法` typedef 已有类型名 类型别名`。

所以对于以下例子：

```c++
#define INT_PTR int*
typedef int*int_ptr;
INT_PTR a,b;
int_ptr c,d;
```

上述定义的四个变量中，只有`b`不是指针类型，因为宏定义是直接替换，其`INT_PTR a,b;`等价于`int* a, b;`,即`a`是整型指针，而`b`是整型变量。而使用了`typedef`,它是类型定义，将`int*`q取别名为``int_ptr`,所以`int_ptr c, d`中两个变量都是整型指针。

**`#define`和`const` 相比有如下劣势**：
1.`const`定义常量是有数据类型的，而`#define`宏定义常量却没有
2.`const`常量有数据类型，而宏常量没有数据类型。**编译器可以对`const`进行类型安全检查**，
   而对**后者只进行字符替换，没有类型安全检查，并且在字符替换中可能会产生意料不到的错误**
3.有些集成化的调试工具可以对`const`常量进行调试，但是不能对宏常量进行调试。

##### 2）sizeof

(1) sizeof 返回的值表示的含义如下（单位字节）：

- 数组 —— 编译时分配的数组空间大小； 
- 指针 —— 存储该指针所用的空间大小（存储该指针的地址的长度，是长整型，应该为 4 ）； 
- 类型 —— 该类型所占的空间大小； 
- 对象 —— 对象的实际占用空间大小； 
- 函数 —— 函数的返回类型所占的空间大小。函数的返回类型不能是 void 。


(2) **C语言: char a = 'a'; sizeof(char) = 1 sizeof(a) = 1 sizeof('a') = 4 **
**C++语言: char a = 'a'; sizeof(char) = 1 sizeof(a) = 1 sizeof('a') = 1 **
**字符型变量是1字节这个没错，奇怪就奇怪在C语言认为'a'是4字节，而C++语言认为'a'是1字节。** 

原因如下:  
* C99标准的规定，'a'叫做整型字符常量(integer    character constant)，被看成是int型，所以在32位机器上占4字节。
* ISO C++标准规定，'a'叫做字符字面量(character literal)，被看成是char型，所以占1字节

(3) `sizeof`求出字符串的字符个数,**包括结尾符**。`strlen`求出字符串的实际字符,**不包括结尾符**

(4) `sizeof`求数组时，大小等于`数组元素个数*每个元素的大小`（其中，计算**字符串数组是需要计算结束符'\0'，**这是与strlen的区别，strlen不计算最后的'\0'），但是当**数组是函数的形参时会将会降为指针**，在**32位系统中无论什么指针类型都是占4个字节**,而**在64位系统，指针则是占8个字节。**

(5) 对**空类或者空结构体** ,对其sizeof操作时候,**默认都是 1个字节**

(6) 对类使用，规则如下：

- 类的大小为类的**非静态成员数据的类型大小之和**，也就是说静态成员数据不作考虑。
- 普通成员函数与sizeof无关。
- 虚函数由于要维护在虚函数表，所以要占据一个指针大小，也就是4字节。
- 类的总大小也遵守类似class字节对齐的，调整规则。

##### 3）变量和表达式
* **左值只能是变量**,不能是表达式 
* **逻辑与的话第一个条件为假就不会再判断第二个条件，逻辑或第一个条件为真也就不会再判断第二个条件**
* 不能对**常量**进行自增运算，如已经声明`int a =5;`，则不能出现`++(a++)`，因为`a++=5`得到常量`5`。

##### 4）编译器

* 编译器只要能**完成程序语言翻译成机器语言**即可，所以**任意语言均可实现**。

* **使用运算符对数据进行格式输出时，必须要包含iomanip.h头文件。**

* 处理器为**大端模式**，**表示低地址存储高位**；**小端模式表示低地址存储低位。**例如，80*86是小端模式。

* 不同编辑器中变量类型的字节长度：

  * 32位编译器：

        char ：1个字节

        char*（即指针变量）: 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理64位编译器）

        short int : 2个字节

        int：  4个字节

        unsigned int : 4个字节

        float:  4个字节

        double:   8个字节

        long:   4个字节

        long long:  8个字节

        unsigned long:  4个字节

  * 64位编译器：

        char ：1个字节

        char*(即指针变量): 8个字节

        short int : 2个字节

        int：  4个字节

        unsigned int : 4个字节

        float:  4个字节

        double:   8个字节

        long:   8个字节

        long long:  8个字节

        unsigned long:  8个字节

##### 5）字符串相关函数

* 对于`strcmp()`函数，比较两个字符串，设这两个字符串为str1，str2：
* 若str1==str2，则返回零；
* 若str1>str2，则返回正数；
* 若str1<str2，则返回负数。
* 对于`strcpy()`函数，复制函数，**会自动在复制后的字符串上添加‘\0’**。
* 对于`strcat(char  *dest, const  char  *src)`函数，连接两个字符串；strcat()会将参数src字符串 拷贝到 参数dest所指的字符串尾。 第一个参数dest要有足够的空间来容纳要拷贝的字符串。
* 字符串格式输出：要输出百分号`%`,必须使用`%%`才可以。
* `string`类的函数`c_str()`返回的是`const char* `，是一个指向C字符串的指针，因此对于两个`string`类型的变量`a, b`,如果使用`a.c_str() == b.c_str()`是对两个指针进行比较。

##### 6）其他函数

* **`int abs(int num)`**

  正常情况下,

  **num为0或正数时**，函数返回num值；

  **当num为负数且不是最小的负数时**（不要问我最小的int类型负数是多少，上面那个图里面有真相），函数返回num的对应绝对值数，即将内存中该二进制位的符号位取反，并把后面数值位取反加一；

  **当num为最小的负数时**（即0x80000000），由于正数里int类型32位表示不了这个数的绝对值，所以依然返回该负数。

* **`memcpy`与`memmove`函数**

  `memcpy`与`memmove`的目的都是将**N个字节的源内存地址的内容拷贝到目标内存地址**中。

  但当**源内存和目标内存存在重叠**时，`memcpy`会出现错误，而`memmove`能正确地实施拷贝，但这也增加了一点点开销。

  因此**`memmove`函数可以在源地址和目的地址的位置任意的情况下，在源地址和目的地址的空间大小任意的情况下实现二进制代码块的复制**

* **`void *memset(void *s, int ch, size_t n);`**  

  函数解释：将s中前n个字节 （typedef unsigned int size_t ）用ch替换并返回s.

  作用是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法,通常为新申请的内存做初始化工作.

* **void \*malloc(size_t size);**
  **malloc**默认返回的是**空指针void\***,需要在**malloc** 前面指定类型，比如`char *p1= (char*) malloc(100)`。其次在**函数内部`malloc`的内存需要 `free`**

* **malloc**需要头文件"stdlib.h"或者"malloc.h"，`malloc/free`只是分配内存/回收内存

* **`dynamic_cast<>`用于C++类继承多态间的转换，**分为：
  1.子类向基类的向上转型(Up Cast)
  2.基类向子类的向下转型(Down Cast)
  其中向上转型不需要借助任何特殊的方法，只需用将子类的指针或引用赋给基类的指针或引用即可，**dynamic_cast向上转型其总是肯定成功的**。

  **而向下转换时要特别注意：dynamic_cast操作符，将基类类型的指针或引用安全的转换为派生类的指针或引用。**dynamic_cast将一个基类对象指针（或引用）cast到继承类指针，dynamic_cast会根据基类指针是否真正指向继承类指针来做相应处理。这也是dynamic_cast与其他转换不同的地方，dynamic_cast涉及运行时类别检查，如果绑定到引用或指针的对象不是目标类型的对象，则dynamic_cast失败。如果是指针类型失败，则dynamic_cast的返回结果为0，如果是引用类型的失败，则抛出一个bad_cast错误。
  **注意：dynamic_cast在将父类cast到子类时，父类必须要有虚函数。因为dynamic_cast运行时需要检查RTTI信息。只有带虚函数的类运行时才会检查RTTI。**

##### 7）编程基础

* 正数的原码、补码和反码都是它本身；负数的最高位是1，表示为负数，它的反码按位取反，然后补码就是反码加1.

​       举例说明：

​       减法7-3相当于加法 7+（-3）
​       被加数7的二进制代码为 0000 0111
​	加数-3的二进制代码为 1000 0011
​	-3的二进制反码为 1111 1100
​	-3的二进制补码为 1111 1101（反码加1）
​	即 7-3 相当于7+（-3）=0000 0111+1111 1101=0000 0100=4

* 计算机存储的是补码，对于`signed char a = 0xe0;`，即`1110 0000`,其原码应该就是`1010 0000`,也就`-32`了。然后`unsigned int b = a;`，由于`a`是负值，所以转为32位的补码，也就是`11111111 11111111 11111111 11100000`,也就是`0xffffffe0`.

因此，定点二进制运算器中，**减法运算一般通过补码运算的二进制加法器实现**

* 下面是求二进制数1的个数的代码实现：
```c++
// 求二进制数1的个数
int numOfOne(int x){
  int count = 0;
  while(x){
    count++;
    x &= x-1;
  }
  return count;
}
```

而求二进制数0的个数代码如下：
```c++
int numOfZero(int x){
  int count = 0;
  while(x+1){
    count++;
    x |= x+1;
  }
  return count;
}
```

* 空指针是一个特殊的指针值。空指针是指可以**确保没有指向任何一个对象**的指针。**通常使用宏定义NULL来表示空指针常量值。NULL就代表系统的0地址单元**。空指针**确保它和任何非空指针进行比较都不会相等，因此经常作为函数发生异常时的返回值使用**。

* `#include<filename.h>`:表示**只从从标准库文件目录下搜索**，对于标准库文件搜索效率快。
  `#include"filename.h"`:表示**首先从用户工作目录下开始搜索**，对于自定义文件搜索比较快，**然后搜索整个磁盘。**

* 源码 ->（扫描）-> 标记 ->（语法分析）-> 语法树 ->（语义分析）-> 标识语义后的语法树 ->（源码优化）-> 中间代码 ->（代码生成）-> 目标机器代码 ->（目标代码优化）-> 最终目标代码

* 一般高级语言程序编译的过程：**预处理、编译、汇编、链接**（参考[编译原理 (预处理>编译>汇编>链接)（转）](http://www.cnblogs.com/pipicfan/archive/2012/07/10/2583910.html))
  * **预处理：**C语言程序从源代码变成可执行程序的第一步，主要是C语言编译器对各种预处理命令进行处理，**包括头文件的包含、宏定义的扩展、条件编译的选择**等。
  * **编译：**编译程序工作时，先分析，后综合，从而得到目标程序。**所谓分析，是指词法分析和语法分析；所谓综合是指代码优化，存储分配和代码生成。**值得一提的是，大多数的编译程序直接产生机器语言的目标代码，形成可执行的目标文件，但也有的编译程序则先产生汇编语言一级的符号代码文件，然后再调用汇编程序进行翻译加工处理，最后产生可执行的机器语言目标文件。 
  * **汇编：**把作为中间结果的汇编代码翻译成了机器代码，即目标代码，不过它还不可以运行。
  * **链接：**处理可重定位文件，**把它们的各种符号引用和符号定义转换为可执行文件中的合适信息(一般是虚拟内存地址)的过程。**链接又分为**静态链接和动态链接**，前者是程序开发阶段程序员用ld(gcc实际上在后台调用了ld)静态链接器手动链接的过程，而动态链接则是程序运行期间系统调用动态链接器(ld-linux.so)自动链接的过程。


##### 8）面向对象的五个基本原则（**Solid**）

* **单一职责原则（Single-Resposibility Principle）**：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。 
* **开放封闭原则（Open-Closed principle）**：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。 
* **里氏替换原则（Liskov-Substituion Principle）**：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。
* **接口隔离原则（Interface-Segregation Principle）**：使用多个小的专门的接口，而不要使用一个大的总接口
* **依赖倒置原则（Dependecy-Inversion Principle）**：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 


#####   9）case标签

​	带标签的语句是一种特殊的语句，在语句前面有一个**标识符（即标签，下面代码中的http）和一个冒号**。使用`goto *label*`就可以跳到标签处执行，比如可以在代码中写`goto http`，这样就会执行`cout`语句了。

```c++
#include<iostream>  
using namespace std;  
int main()  
{  
    http://www.csdn.net  
    cout<<"hello world!"<<endl;  
    return 0;  
}  
```

 **case就是一种标签，case关键字和它对应的值一起，称为case标签。**

类中的**public、private、protect也是标签，称为成员访问标签。**

`case`标签必须是**整型常量**表达式，具体条件如下：

（1）C++中的const int，注意仅限于C++中的const，C中的const是只读变量，不是常量；

（2）单个字符，如case 'a': 是合法的，因为文字字符是常量，被转成ASCII码，为整型；

（3）使用#define定义的整型，#define定义的一般为常量，比如#define pi 3.14，但是也必须是整型才可以；

（4）使用enum定义的枚举成员。因为枚举成员是const的，且为整型。如果不手动指定枚举值，则默认枚举值为从0开始，依次加1。

具体参考文章 [C++中的case标签](http://blog.csdn.net/szchtx/article/details/21647159) 。

##### 10） enum

enum中：首元素不赋值的话，默认为0；后一个元素不赋值的话比前一个元素大1

##### 11） 转义字符

转移字符分三种，一般转义字符，八进制转移字符和十六进制转移字符

* **一般转义字符**，如‘\b’，由两个字符表示，其实代表一个字符，这个代表退格字符
* *八进制转义字符**，如‘\007’,三位数字是八进制的，ASCII码为7的表示响铃**
* 十六进制**，如'\xfe'，同样后面数字是所表示意思的Ascii码的十六进制表示，注意一定要有x，大小写都行


##### 12）STL知识

* **STL一级容器是容器元素本身是基本类型，非组合类型**，因此有**vector, deque, list。**

  而**set, multiset**中元素类型是pair<key_type, key_type>;**map, multimap**中元素类型是pair<key_type, value_type>;

* STL中的常用容器包括：**顺序性容器（vector、deque、list）、关联容器（map、set）、容器适配器（queue、stac）**

**一、顺序**容器：

**vector：**可变大小数组；

**deque：**双端队列；

**list：**双向链表；

**forward_list：**单向链表；

**array**：固定大小数组；

**string**：与vector相似的容器，但专门用于保存字符。

**二、关联**容器：

按**关键字有序**保存元素：（底层实现为**红黑树**）

**map：**关联数组；保存关键字-值对；

**set：**关键字即值，即只保存关键字的容器；

**multimap：**关键字可重复的map；

**multiset：**关键字可重复的set；

**无序**集合：

**unordered_map：**用哈希函数组织的map；

**unordered_set：**用哈希函数组织的set；

**unordered_multimap：**哈希组织的map；关键字可以重复出现；

**unordered_multiset：**哈希组织的set；关键字可以重复出现。

三、其他项：

**stack、queue、valarray、bitset**

* **STL容器是线程不安全的**
* **std::sort**封装了快速排序算法，是不稳定算法。
* `vector`在执行函数`erase()`后，会指向下一个元素的位置，也就是执行该函数的时候，后面的元素都会向前移动，而迭代器位置没有移动。
* ​

##### 13）内存分配

* **对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。**

* ```c++
  #pragma pack(2)
  class BU
  {
      int number; // 4
      union UBffer
      {
          char buffer[13]; // 13
          int number; // 4
      }ubuf; // union的大小取决于它所有的成员中，占用空间最大的一个成员的大小，并且需要内存对齐，这里因为#pragma pack(2)，所以union的大小为14，如果不写#pragma pack(2)，那么union大小为16【因为与sizeof（int）=4对齐】
      void foo(){} //0
      typedef char*(*f)(void*); //0
      enum{hdd,ssd,blueray}disk; // 4
  }bu;

  因此sizeof（union） = 4+14 +0 +0 +4 = 22
  ```

* 结构体的内存对齐默认是8个字节。

  1、  **结构体的大小等于结构体内最大成员大小的整数倍**
  2、  结构体内的成员的首地址相对于结构体首地址的偏移量是其类型大小的整数倍，比如说double型成员相对于结构体的首地址的地址偏移量应该是8的倍数。
  3、  为了满足规则1和2编译器会在结构体成员之后进行字节填充！

  ​

* 对Union结构体，sizeof的取值不仅考虑**sizeof最大的成员**，还要考虑对齐字节，**对齐字节的取值是取成员类型字节最大值与指定对齐字节**(32位机器默认是4，64位机器默认是8)两者中的**较小值**

##### 14） Linux 知识

* **BSS（Block Started by Symbol）**通常是指用来存放程序中**未初始化的全局变量和静态变量**的一块内存区域。特点是:可读写的，在程序执行之前BSS段会自动清0。所以，未初始的全局变量在程序执行之前已经成0了。 


------

#### 6. 代码片段

##### 1）交换两个变量的数值

```c++
// 不需要额外设定一个变量的交换方法
int x = 5;
int y = 6;
x += y;
// 将 x 赋值给了 y
y = x-y;
// 将 y 赋值给了 x
x -= y;
```
下面是另一种使用异或交换的方式：

```c++
x ^= y;
y ^= x;
x ^= y;
```

##### 2） 浮点数判断是否为0

浮点数比较是否等于0的方法如下：

```c++
float a;
if(fabs(a)< FLT_EPSILON)
	// 判断是等于0
	return true;
```

在ANSIC C中定义了`FLT_EPSILON/DBL_EPSILON/LDBL_EPSILON`来用于浮点数与零的比较.




[1]: http://www.cnblogs.com/bigrabbit/archive/2012/09/20/2695543.html