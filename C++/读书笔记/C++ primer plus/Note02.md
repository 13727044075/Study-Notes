##第4章 复合类型
###1.数组
数组是一种数据格式，可以同时存储多个同类型的值。

声明数组的通用格式为`typeName arrayName[Size]`，必须包含数组名，数组元素个数以及数组值的类型，其中Size不能是变量，必须是整型常数或const值，或常量表达式。

**初始化规则**

+ 数组只有在声明时才可以初始化，同时不可以将一个数组赋给另一个数组；
+ 可以使用下标分别给数组中的元素赋值
+ 初始化时，提供的值可以少于数组的元素数目，剩下的值会被设置为0
+ 初始化为{0}表示将数组中所有的元素都初始化为0
+ 初始化时方括号内为空，编译器讲计算元素个数，即元素个数等于提供的值，但不推荐这种做法

**C++11的初始化方式**

    # 初始化数组时可以省略等号
    double earnings[4] {1.2,1.6,1.1,1.7};
    # 大括号内不包含任何东西即是将所有元素设置为0
    float balances[100] {};
    # 列表初始化禁止缩窄转换
    long plifs[] = {25,92,3.0}  // 禁止，因为3.0是浮点数，浮点数转换为整数是缩窄操作
    char slifs[4] {'h','i',112,'\0'}; // 允许

###2.字符串
C++处理字符串的方式有两种，一是来自C语言，常被称为C-风格字符串；二是基于String类库的方法。

**C-风格字符串**有一种特殊的性质：以空字符结尾，空字符被写作'\0'。

**(1) 字符串输入**

**cin**使用空白（空格、制表符和换行符）来确定字符串的结束位置，这意味着cin在获取字符数组输入时只读取一个单词

**(2) 面向行的输入：getline()**
    
  使用cin.getline()可以读取整行，使用通过回车键输入的换行符来确定输入结尾。它有两个参数，第一个是用来存储输入的数组的名称，第二个参数是要读取的字符数，若这个参数是20，则最多读取19个字符，剩下的空间用于存储自动在结尾处添加的空字符。

  getline()是通过换行符来确定行尾，但是不保存换行符。

**(3) 面向行的输入:get()**

  get()工作方式与getline()相似，接受的参数相同，解释参数的方式也相同，并且都读取到行尾，但get不会丢弃换行符，而是将其留在输入队列，所以在连续两次调用get()时，第二次get方法看到的第一个字符就是换行符，解决方法是用不带任何参数的cin.get()来读取下一个字符，可以用它来处理换行符，使用例子如：`cin.get(name, ArSize).get();`

**(4) 混合输入字符和数字**
对于混合输入，需要处理的问题也是换行符，在输入数字后，需要加上`cin.get()`来接受换行符，保证后面的输入可以正常执行。

###3.String类简介
使用String类，必须在程序中包含头文件string，string类位于名称空间std中，因此必须提供一条using编译指令，或者使用std::string来引用它。

使用string的方式与使用字符数组在很多方面都相同:

* 可以使用C-风格字符串来初始化string对象
* 可以使用cin来将键盘输入存储到string对象中
* 可以使用cout来显示string对象
* 可以使用数组表示法来访问存储在string对象中的字符

####(1) 赋值、拼接和附加
* 可以将一个string对象赋给另一个string对象
* 可以使用运算符+合并两个或多个string对象，也可以使用运算符+=将C-风格字符串或string对象附加到string对象的末尾

####(2) string类其它操作
* 对于C-风格字符串，在头文件cstring中提供了一些函数来完成诸如赋值等操作，如函数strcpy()可以将字符串复制到字符数组中，strcat()函数将字符串附加到字符数组末尾，strlen()函数可以返回字符串或字符数组包含的字符数

* 对于string，使用其size()方法可以返回string包含的字符数

* string类I/O：输入使用如`getline(cin, str);`的形式将键盘输入存储到string对象str中

###4.结构简介
* 结构是一种比数组更灵活的数据格式，同一个结构可以存储多种类型的数据。创建结构分为结构定义和创建结构变量。

一个定义结构的代码例子:

    struct inflatable
    {
        char name[20];
        float volume;
        double price;
    };
这里是需要有关键字**struct**,它表明这些代码定义的是一个结构的布局。

结构初始化的方式如下所示:

    inflatable guest = 
    {
        "Glorious Gloria",
        1.88,
        29.99
    };
    // 也可以全部放在一行
    inflatable duck = {"Daphne", 0.12, 9.98};

* 结构中访问成员使用成员运算符(.),如上述例子中，duck.name是一个字符数组，指的是那么成员
* 结构声明可以放在main()函数前面，这称为外部声明，也可以放在main()函数中。通常应该使用外部声明，这样所有函数都可以使用这种类型的结构
* C++11也支持将列表初始化用于结构，也就是可以省略等号；其次，如果大括号不包含任何东西，各个成员都将被设置为0；最后，同样不允许缩窄转换
* 结构也可以将string类作为成员，但要让结构定义能够访问名称空间std

**结构属性**
    
* 可以将结构作为参数传递给函数，也可以让函数返回一个结构
* 可以使用赋值运算符=将结构赋给另一个同类型的结构

**结构数组**，使用例子如下

    inflatable guest[2] = 
    {
        {"Bambi", 0.5, 21.99},
        {"Godzilla", 2000, 565.99}
    };

###5.共同体(union)
共同体是一种能存储不同的数据类型，但只能同时存储其中的一种类型。

使用例子如下：

    // 声明
    union one4all
    {
        int int_val;
        long long_val;
        double double_val;
    }
    // 该共同体可以存储int，long或double，条件是在不同的时间进行
    one4all pail;
    pail.int_val = 15;
    cout << pail.int_val;
    pail.double_val = 1.38; // 保存double，int值会丢失
    cout << pail.double_val;
所以共同体每次只能存储一个值，其长度为最大成员的长度。它常用于节省内存。

###6.枚举
**enum**提供了另一种创建符号常量的方式，这种方式可以代替const,它还允许定义新类型。
如`enum spectrum {red, orange, yellow, green, blue, violet, indigo, ultraviolet};`

这句话完成了两项工作:

* 让spectrum成为新类型的名称；spectrum被称为枚举
* 让red、orange、yellow等作为符号常量，它们对应整数值0-7，这些常量叫做枚举量

可以将枚举名来声明这种类型的变量--`spectrum band`

枚举变量的属性如下：

* 在不进行强制类型转换的情况下，只能将定义枚举时使用的枚举量赋给这种枚举的变量，如`band = blue;`,这是正确的，而`band = 2000;`则是不合法的

* 对于枚举，只是定义了赋值运算符，也就是没有为枚举定义算术运算
* 枚举量是整型，可被提升为int类型，但int类型不能自动转换为枚举类型，如`int color = blue;`是有效的，`band = 3;`是不合法的，也就是说可以将枚举量赋给int类型，但是不能把int类型赋给枚举量

####(1).设置枚举量的值
可以使用赋值运算符来显示地设置枚举量的值，如下例子

    enum bits{one = 1, two = 2, four = 4};
    // 指定的值必须是整数，也可以只显示定义其中一些枚举量的值
    enum bigstep{first, second = 100, third};   // 这里的frist默认情况下为0
    // 可以创建多个值相同的枚举量
    enum {zero, null = 0, one, numero_uno = 1}; // 这里，zero和null都是0，one和numero_uno都是1

####(2).枚举的取值范围
取值范围的定义如下。首先要找出上限，需要知道枚举量的最大值，找到大于这个最大值的、最小的2的幂，将它减去1，得到的便是取值范围的上限，如枚举量最大值是101，则在2的幂中比这个数大的最小值是128，则取值范围的上限是127；而对于下限，如果枚举量最小值不小于0，则下限是0，否则，则跟寻找上限方向相同，但加上负号。例如，最小的枚举量是-6，而比它小的、最大的2的幂是-8，因此下限是-7。

###7.指针和自由存储空间
指针是一个变量，其存储的是值的地址，而不是值本身。

对变量使用地址运算符(&),就可以获得它的地址，如果home是一个变量，则&home是它的地址

指针名表示的是地址。\*运算符被称为间接值或解除引用运算符，将其应用于指针，可以得到该地址处存储的值。例如，设ptr是一个指针，则ptr表示的是一个地址，而\*ptr就表示存储在该地址处的值。

####(1).声明和初始化指针
声明的格式如`int * ptr;`,也可以写作`int* ptr`,`int *ptr`，第二种是C++程序员会使用的，第三种则是C程序员使用的，**注意**，每个指针变量名都需要使用一个\*，这个声明表示ptr是指向int类型，即\*ptr是int类型的值

**初始化**的方式如下

    int higgen = 5;
    int * pt = &higgen;

**在C++中创建指针时，计算机只是分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存，换句话说就是一定要在对指针应用解除应用运算符(\*)之前，将指针初始化为一个确定的、适当的地址。**

####(2).使用new来分配内存
* 指针的真正用武之地是在运行阶段分配未命名的内存以存储值，在C语言中可以用库函数malloc()来分配，而C++中可以用new运算符。

* 使用new分配内存的例子如`int * pt = new int;`，new int告诉程序需要适合存储int的内存，new运算符根据类型来确定需要多少字节的内存，然后它找到这样的内存，并返回其地址，然后将地址赋给pt。

* new是从被称为堆(heap)或自由存储区的内存区域分配内存，而常规变量声明分配的内存块是在被称为栈(stack)的内存区域中。

####(3).使用delete释放内存
需要内存可以用new来请求，但使用完内存后必须使用delete运算符来释放内存。

    int * ps = new int;
    ...
    delete ps;
以上是使用delete释放内存的一个例子，这会释放ps指向的内存，但是不会删除指针ps本身，还可以将ps重新指向另一个新分配的内存快。

* 一定要配对使用new和delete,否则会发生内存泄露，也就是说，被分配的内存再也无法使用了。
* 不要尝试释放已经释放的内存块
* 对空指针使用delete是安全的
* 一般来说，不要创建两个指向同一个内存块的指针，因为这将增加删除同一个内存块两次的可能性。

####(4).使用new创建动态数组
例子:`int * pt = new int [10];`,当使用完后应该添加这行语句`delete [] pt;`释放内存

* 使用new[]为数组分配内存，则应该使用delete[]来释放
* 访问动态数组可以按照数组表示法的方式，即pt[0]就表示第一个元素，而pt[1]表示第二个元素

###8.指针、数组和指针算术
####(1)指针小结
* 指针和数组基本等价的原因在于指针算术和C++内部处理数组的方式。在多数情况下，C++将数组名解释为数组第一个元素的地址。
* 将指针变量加1后，其增加的值等于指向的类型占用的字节数
* 对于数组表达式arr[1],等价于\*(arr + 1)，同样的对于指针pr[1],也等同于\*(pr + 1)
* 多数情况下，可以使用相同的方式使用指针名和数组名，即可以使用数组方括号表示法，也可以使用解除引用运算符(\*),但区别之一是可以修改指针的值，而数组名是常量；另一个区别是对数组应用sizeof运算符得到的是数组的长度，而对指针使用sizeof得到的是指针的长度

* 对数组名使用地址运算符，得到的是整个数组的地址，如`short tell[10];`，&tell[0]是一个2字节内存块的地址，而&tell是一个20字节内存块的地址，那么表达式tell+1将地址加2，而&tell+1将地址加20

* 一般来说，如果给cout提供一个指针，它将打印地址，但是如果指针的类型是char \*,则cout将显示指向的字符串，要显示字符串的地址，则需要将这种指针强制转换为另一种指针类型，如int \*

* 经常需要将字符串赋给数组，在初始化数组时使用=运算符，否则要使用strcpy()或strncpy()函数，后者可以有第三个参数，指定要复制的最大字符数

* 使用new创建动态结构。使用这种方式创建结构后，访问成员不能用成员运算符(.),要使用箭头成员运算符(->)；另一种访问方法是，如果ps是指向结构的指针，则\*ps就是结构本身，所以可以使用(\*ps).price(假设price是ps指向的结构的一个成员)

####(2)自动存储、静态存储和动态存储
* 在函数内部定义的常规变量使用自动存储空间，被称为自动变量，其通常存储在栈中，它是一个局部变量，其作用域就是包含它的代码块。
* 静态存储是整个程序执行期间都存在的存储方式。有两种实现方式，一个是在函数外面定义，另一个就是在声明变量时使用关键字static：`static double fee = 56.5;`
* 动态存储就是使用new和delete运算符实现的一种存储方法，它们管理一个内存池，这在C++中称为自由存储空间或堆，它跟用于静态变量和自动变量的内存是分开的。在栈中，自动添加和删除机制使得占用的内存总是连续的，但new和delete的相互影响可能导致占用的自由存储区不连续，这使得跟踪新分配内存的位置更困难。

###9.数组的替代品
####(1) 模板类vector
* vector类似于string类，也是一种动态数组。可以在运行阶段设置vector对象的长度，可在末尾附加新数据，也可以在中间添加新数据；
* 使用vector对象，必须包含头文件vector；
* 其次，vector包含在名称空间std中；
* 模板使用不同的语法指出它存储的数据类型，以及它的元素数。

下面是一些示例:

    #include<vector>
    ...
    using namespace std;
    vector<int> vi;     // 创造了一个长度为0的int数组
    int n = 5;
    vector<double> vd(n);   // 创建了一个长度是n的double数组

####(2) 模板类array(C++11)
* C++11新增的模板类array，其长度固定，使用栈，使用要包含头文件array，创建的格式为:`array<typeName, n_elem> arr`
* 初始化方式跟数组相同，即大括号的初始化方式

###10.总结
这章内容介绍了复合类型，主要是数组，字符串，string类，结构，共同体，枚举，指针以及vector和array，其中最难掌握的应该就是指针了，不过这章对于指针的介绍还只是简单介绍而已，还是可以掌握的。




