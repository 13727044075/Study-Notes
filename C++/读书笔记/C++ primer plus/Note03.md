##第5章 循环和表达式
###1. for循环
* C++表达式是值或值与运算符的组合，每个C++表达式都有值
* 任何表达式加上分号都可以成为语句，但是反过来说就不对，如返回语句、声明语句和for语句都不满足"语句 = 表达式 + 分号"
* 通常，定义一个const值来表示数组中的元素个数是个好办法。在声明数组和引用数组长度时可以使用const值

#####(1) 副作用和顺序点
* 副作用是值在计算表达式时对某些东西(如存储在变量中的值)进行了修改；
* 顺序点是程序执行过程中的一个点，在这里，进入下一步之前将确保对所有的副作用都进行了评估；C++中，语句中的分号就是一个顺序点，另外，任何完整的表达式末尾都是一个顺序点

#####(2) 递增/递减运算符和指针
* 对于递增/递减运算符，有前缀和后缀两种格式，后缀格式首先是复制一个副本，然后加/减1，然后将复制的副本返回，而前缀格式就是加/减1，然后返回结果，所以前缀格式的效率会高于后缀格式
* 前缀递增/递减和解除引用运算符的优先级相同，是以从右到左的方式进行结合；而后缀递增和后缀递减优先级相同，但比前缀运算符优先级高，这两个运算符从左到右结合

* 对于前缀运算符，如`*++pt`首先是将++应用于pt，再使用解除引用\*，其效果就是pt的地址加1，再返回此时指向的数值，如原来是指向数组arr[0],现在就是得到arr[1]的值；对于`++*pt`，则是先得到pt指向的数值，然后令其加1
* 对于后缀运算符，如`(*pt)++`,首先是得到pt指向的值，再加1，效果如同`++*pt`；
对于`*pt++`，则是让指针增加，但是其解除引用时是作用在原来的地址，如原来pt是指向arr[0],返回的值也是arr[0]，但是这语句执行完毕后，pt指向的是arr[1]

#####(3) C-风格字符串的比较
* C++将C-风格字符串视为地址，因此如果使用关系运算符比较它们，只是判断它们是否存储在相同的地址上，而不是判断两者是否相等
* 正确的做法是使用**strcmp()**函数来比较，如果两个字符串相同，该函数返回0；如果第一个字符串按字母顺序排在第二个字符串之前，则返回一个负数值，否则是返回正数值；
* 关系运算符是可以用来比较字符的，因为字符实际上是整型
* 对于string类字符串，可以直接使用关系运算符比较

#####(4) 类型别名
C++为类型建立别名的方式有两种，一种是使用预处理器`#define BYTE char`，这样BYTE成为char的别名；

第二种方法是使用关键字typedef，如上述例子可以写成`typedef char byte;`,所以其通用格式是`typepdef typeName aliasName;`

在声明一系列变量的时候就不能使用#define方法，只能使用typedef，typedef方法并不会创建新类型，只是为已有的类型建立新的名称

#####(5) 基于范围的for循环(C++11)
C++11新增了一种基于范围的for循环，使用例子如下:

    double prices[5] = {4.9, 2.5, 6.8, 7.9, 8.9};
    for (double x: prices)
        cout << x << endl;
如果是要改变数组的元素，上述例子中应该用&x代替x，这里的&表明x是一个引用变量

###2. 嵌套循环和二维数组
#####(1) 初始化二维数组
初始化二维数组可以如下例子:

    int maxtemps[2][3] = 
    {
        {22, 33, 55},
        {36, 28, 50}
    };

#####(2) 使用二维数组
C++常用的一个初始化字符串常量的做法是用一个指针数组，如：

    const char * cities[3] = 
    {
        "New Gribble",
        "San Gribble",
        "Gribble Vista"
    };
当然也可以使用一个二维数组，如`const char cities[3][25]`,但从存储空间角度，使用指针数组更为经济，而如果要修改其中任何一个字符串，则二维数组是更好的选择；

另外，还可以使用string数组，如`const string cities[3]`,这里使用const表明数组是不可修改的，如需修改字符串，则可省略const。