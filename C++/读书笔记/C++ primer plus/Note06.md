##第8章 函数探幽
###1. C++内联函数
* 常规函数和内联函数的主要区别是C++编译器如何将它们组合到程序中。内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。
* 要使用内联函数，必须在函数声明和定义前加上关键字inline；通常的做法是省略原型，将整个定义放在本应提供原型的地方

###2. 引用变量
#####(1) 创建引用变量
* 引用是已定义的变量的别名，引用变量的主要用途是用作函数的形参；
* C++使用&符合来声明引用，如`int & rodents = rats;`这里用rodents作为rats变量的别名
* 注意，必须在声明引用变量时进行初始化，其用法接近const指针，一旦与某个变量关联起来，就讲一直效忠于它。

#####(2) 将引用用作函数参数
* 引用经常被用作函数参数，使得函数中的变量名成为调用程序中的变量的别名，这种传递参数的方法称为按引用传递。
* 用作函数参数时，需要在函数原型和定义中添加&符号，而在调用函数时，直接传入实参名，不需要添加&符号。
* 使用引用作为函数参数，需要注意可能会修改原来传入函数的变量值，要防止这种现象，可以在函数头中使用const
* 如果实参与引用参数不匹配，C++将生成临时变量。当前，仅当参数是const引用时，C++才允许这样做
* **左值参数**是可被引用的数据对象，如变量，数组元素，结构成员，引用和解除引用的指针；而非左值包括字面常量(用引号括起的字符串除外，它们由其地址表示)和包含多项的表达式
* 将引用参数声明为常量数据的引用的原因是：一是使用const可以避免无意中修改数据的编程错误；二是使函数能够处理const和非const实参，否则只能接受非const数据；三是使函数能够正确生成并使用临时变量
* C++11新增了另一种引用--右值引用，它可指向右值，是使用&&声明的，如`double && jref = 2.0* j + 18.5;`

#####(3) 何时使用引用参数
使用引用参数的主要原因有两个：

* 能够修改调用函数中的数据对象
* 通过传递引用而不是整个数据对象，可以提高程序的运行速度

对于使用传递的值而不作修改的函数：

* 如果数据对象很小，如内置数据类型或小型结构，则按值传递
* 如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针
* 如果数据对象时较大的结构，则使用const指针或const引用，以提高程序的效率，这样可以节省复制结构所需的时间和空间
* 如果数据对象时类对象，则使用const引用。

对于修改调用函数中数据的函数：

* 如果数据对象是内置数据类型，则使用指针
* 如果数据对象是数组，只能使用指针
* 如果数据对象是结构，则使用引用或指针
* 如果数据对象是类对象，则使用引用

###3. 默认参数
* 默认参数指的是当函数调用中省略了实参时自动使用的一个值
* 设置默认参数必须通过函数原型，而函数定义与没有默认参数时完全相同；此外对于带参数列表的函数，必须从右向左添加默认值，也就是要为某个参数设置默认值，则必须为它右边的所有参数提供默认值
* 提供了默认参数后，实参按从左到右的顺序依次被赋给相应的形参，而不能跳过任何参数

###4. 函数重载
* 函数重载跟函数多态指的是同一回事，即可以有多个同名的函数，但使用不同的函数列表
* 函数重载的关键是函数的参数列表，也被称为函数特征标；如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同
* C++允许定义名称相同的函数，条件是它们的特征标不同，即当参数数目和/或参数类型不同，则特征标也不同
* 当返回类型不同时，特征标也必须不同

###5. 函数模板
* 函数模板是通用的函数描述，也就是说使用泛型来定义函数，其中的泛型可以用具体的类型(如int或double)替换
* 由于模板允许以泛型的方式来编写程序，因此有时也被称为通用编程

函数模板允许以任意类型的方式来定义函数，例如，可以这样建立一个交换模板：

    template <typename AnyType>
    void Swap(AnyType &a, AnyType &b){
        AnyType temp;
        temp = a;
        a = b;
        b = temp;
    }
关键字template和typename是必需的，除非可以使用关键字class代替typename;另外必须使用尖括号；类型名可以任意选择(这里是AnyType),只有符合C++命名规则即可，许多程序员都使用简单的名称，如T

* 注意，函数模板不能缩短可执行程序，最终的代码不包含任何模板，而只包含了为程序生成的实际函数；使用模板的好处是它使生成多个函数定义更简单可靠
* 一般将模板放在头文件中，并在需要使用模板的文件中包含头文件

#####(1) 重载的模板
* 需要多个对不同类型使用同种算法的函数时，可以使用模板，但不是所有类型都使用同种算法，此时可以使用重载，和常规重载一样，被重载的模板的函数特征标必须不同
* 并非所有的模板参数都必须是模板参数类型，也可以是基本数据类型，如int等

#####(2) 显式具体化
在试验了其他具体化方法后，C++98标准选择了下面的方法：

* 对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及它们的重载版本
* 显式具体化的原型和定义应以**template<>**打头，并通过名称来指出类型
* 具体化优先于常规模板，而非模板函数优先于具体化和常规模板

示例如下,这是用于交换job结构的例子:

    // 非模板函数
    void Swap(job &, job &);
    // 模板函数
    template <typename T>
    void Swap(T &, T &);
    // 显示具体化
    template <> void Swap<job>(job &, job &);
上述显示具体化可以简单写成`template <> void Swap(job &, job &);`

#####(3) 实例化和具体化
* 在代码中包含函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案
* 编译器使用模板为特定类型生成函数定义时，得到的模板实例，这种实例化方式被称为隐式实例化
* 显式实例化的语法是声明所需的种类，使用<>符号指示类型，并在声明前加上关键字template，如`template void Swap<int>(int, int);`,该声明的意思是“使用Swap()模板生成int类型的函数定义”
* 对于显式具体化，则其意思是“不要使用Swap()模板来生成函数定义，而应使用专门为int类型显式地定义的函数定义”
* 注意，试图在同一个文件(或转换单元)中使用同一种类型的显式实例化和显式具体化将出错
* 隐式实例化、显式实例化和显式具体化都是具体化，它们的相同之处在于，它们表示的都是使用具体类型的函数定义，而不是通用描述

#####(4) 编译器选择使用哪个函数版本
对于函数重载、函数模板和函数模板重载，C++需要(且有)一个定义良好的策略，来决定为函数调用使用哪一个函数定义，尤其是有多个参数时，这个过程称为重载解析。

编译器首先会选择同名称的函数和函数模板，然后是寻找参数数目相同的函数，接下来编译器必须确定哪个可行函数是最佳的，通常，从最佳到最差的顺序如下所述。

1. 完全匹配，但常规函数优先于模板
2. 提升转换(如，char和short自动转换为int，float自动转换为double)
3. 标准转换(如，int转换为char，long转换为double)
4. 用户自定义的转换，如类声明中定义的转换

下图是列出了在进行完全匹配时，C++允许的无关紧要转换，Type表示任意类型。
![完全匹配允许的无关紧要转换](https://raw.githubusercontent.com/ccc013/Study-Notes/master/images/%E5%AE%8C%E5%85%A8%E5%8C%B9%E9%85%8D%E5%85%81%E8%AE%B8%E7%9A%84%E6%97%A0%E5%85%B3%E7%B4%A7%E8%A6%81%E8%BD%AC%E6%8D%A2.png )

在有多个函数都完全匹配的情况下，有时候存在最佳匹配的情况，如：

1. 对于指向非const的指针和引用，即分别是const的指针或引用和非const的指针或引用，优先匹配非const的指针或引用，这是const和非const之前的区别，即只是在有指针和引用的情况；
2. 一个是模板函数，而另外一个是非模板函数，这种情况，非模板函数将优先于模板函数
3. 当两个完全匹配的函数都是模板函数，则较具体的模板函数优先

**创建自定义的选择**

假设定义了函数Swap(T &, T &),当调用该函数时，`Swap<>(m,n)`中的<>指出编译器应选择模板函数，而`Swap<int>(x,y)`则要求进行显式实例化。




