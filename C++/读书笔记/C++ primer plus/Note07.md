##第9章 内存模型和名称空间
###1. 单独编译
头文件中常包含以下内容：

* 函数原型
* 使用#define或const定义的符号常量
* 结构声明
* 类声明
* 模板声明
* 内联函数

在包含头文件时，如果文件名包含在尖括号中，则C++编译器将在存储标准头文件的主机系统的文件系统中查找；如果文件名包含在双引号中，则编译器讲首先查找当前的工作目录或源代码目录，因此在包含自己的头文件时，应使用引号而不是尖括号。

**头文件管理**

在同一个文件中只能将同一个头文件包含一次，为了避免多次包含同一个头文件，可以使用如下语句：

    #ifndef COORDIN_H_
    #define COORDIN_H_
    ...
    #endif
编译器首次遇到该文件时，名称COORDIN_H_没有定义，这是根据include文件名来选择名称，并加上一些下划线，以创建一个在其他地方不太可能被定义的名称。这种情况下，编译器将查看#ifndef和#endif之间的内容，并读取定义COORDIN_H_的一行。

注意，这种方法并不能防止编译器讲文件包含两次，而只是让它忽略除第一次包含之外的所有内容。

###2. 存储持续性、作用域和链接性
#####(1) 作用域和链接
* 作用域描述了名称在文件(翻译单元)的多大范围内可见
* 链接描述了名称如何在不同单元间共享。链接性为外部的名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共享。
* 自动变量的名称没有链接性，因为它们不能共享

* C++变量的作用域有多种，其作用域可以是局部的，也可以是全局的
* C++函数的作用域可以是整个类或整个名称空间(包括全局的),但不能是局部，因为不能在代码块内定义函数，如果函数的作用域为局部，则只对它自己是可见，因此不能被其他函数调用，这样的函数将无法运行

#####(2) 自动存储持续性
* 默认情况下，在函数中声明的函数参数和变量的存储持续性为自动，作用域为局部，没有链接性
* 如果在一个内部代码块和外部代码块中都声明了同一个名称的变量，则在内部代码块中，将使用在该代码块内定义的名称，离开该代码块后则使用外部声明的名称

* 关键字register最初是由C语言引入的，它建议编译器使用CPU寄存器来存储自动变量，这旨在提高访问变量的速度

#####(3) 静态持续变量
* 默认情况下，静态数组和结构将每个元素或成员的所有位都设置为0
* 静态存储变量有3种链接性，外部链接性、内部链接性和无链接性。
* 要想创建外部链接性的静态持续变量，必须在代码块外面声明它；创建内部链接性的静态持续变量，也是在代码块外部声明，但是要使用**static**限定符；创建无链接性的静态持续变量，必须在代码块内声明，并加上**static**限定符

**静态持续性、外部链接性**

* 链接性为外部的变量通常称为外部变量，也称为全局变量
* C++有“单定义规则”——变量只能有一次定义。但在每个使用外部变量的文件中都必须声明它
* 为了满足这个需求，C++提供了两种变量声明，一种是定义声明或简称为定义(definition)，它给变量分配存储空间；另一种是引用声明或简称为声明(declaration)，它不给变量分配存储空间，因为它引用已有的变量,它使用关键字**extern**，且不进行初始化
* 如果在多个文件中使用外部变量，只需要在一个文件中包含该变量的定义，在其他文件中使用关键字extern声明它
* 单定义规则并非意味着不能有多个变量的名称相同，如在不同函数中声明的同名自动变量是彼此独立的，它们都有自己的地址，且局部变量可能隐藏同名的全局变量

**静态持续性、无链接性**

在代码块中使用static，将导致局部变量的存储持续性为静态的，这意味着虽然该变量只在该代码块中可用，但它在该代码块不处于活动状态时仍然存在。因此，在两次函数调用之间，静态局部变量的值将保持不变。另外，如果初始化了静态局部变量，则程序只在启动时进行一次初始化，以后再调用函数时，将不会像自动变量那样再次被初始化。

#####(4) 说明符和限定符
**cv限定符——const & volatile**

关键字volatile表明，即使程序代码没有对内存单元进行修改，其值也可能发生变化。例如，可以将一个指针指向某个硬件位置，其中包含了来自串行端口的时间或信息，在这种情况下，硬件(而不是程序)可能修改其中的内容。或者两个程序可能互相影响，共享数据。

该关键字的作用是为了改善编译器的优化能力。

**mutable**

该关键字指出，即使结构(或类)变量为const，其某个成员也可以被修改。例如：

    struct data
    {
        char name[30];
        mutable int accesses;
    };
    const data veep = {"Clodde",0};
    strcpy(veep.name, "Jojy");  // 非法操作
    veep.accesses++;    // 合法操作

**const**

* 默认情况下全局变量链接性是外部的，但是const全局变量的链接性为内部的。
* 如果希望变量的链接性为外部，可以再添加上关键字extern覆盖默认的内部链接性，但在这种情况下，必须在所有使用该常量的文件中使用extern关键字声明它。

#####(5) 函数链接性
* 函数的存储持续性都自动为静态的，默认情况下，函数的链接性是外部的，即可以在文件间共享。
* 可以使用关键字static将函数的链接性设置为内部的，使之只能在一个文件中使用
* 单定义规则也适用于非内联函数，因此对于每个非内联函数，程序只能包含一个定义。所以对于链接性为外部的函数来说，在多文件程序中，只能有一个文件包含该函数的定义，但使用该函数的每个文件都应包含其函数原型。

#####(6) 语言链接性
* 链接程序要求每个不同的函数都有不同的符号名。
* C语言中，一个名称对应一个函数，如C语言编译器可能将spiff这样的函数名翻译为_spiff，这种方法被称为C语言链接性。
* C++中，同一个名称可能对于多个函数，必须将这些函数翻译为不同的符号名称。
* 如果要在C++程序中使用C库中预编译的函数，可以在函数原型前添加`extern "C"`指出其使用C语言链接性。

#####(7) 存储方案和动态分配
* 使用C++运算符new(或C函数malloc())分配的内存，这种内存被称为动态内存；动态内存由运算符new和delete控制，而不是由作用域和链接性规则控制

**使用new运算符初始化**

为内置的标量类型(如int或double)分配存储空间并初始化，可在类型名后面加上初始值，并将其用括号括起，如`int *pi = new int (6);`,则*pi = 6

如果是初始化常规结构或数组，则需要使用大括号的列表初始化，这要求编译器支持C++11，如`int * ar = new int [4] {2,3,4,5};`

**定位new运算符**

定位new运算符可以指定要使用的位置，要使用定位new特性，首先要包含头文件new，然后将new运算符用于提供了所需地址的参数。例如

    #include<new>
    struct chaff
    {
        char name[20];
        int slag;
    };
    char buffer1[50];
    char buffer2[100];
    int main(){
        chaff *p1, *p2;
        int *p3, *p4;
        // 常规用法
        p1 = new chaff;
        p2 = new int[20];
        // 使用定位new运算符
        p3 = new (buffer1) chaff;
        p4 = new (buffer2) int[20];
    }

delete只能用于这样的指针：指向常规new运算符分配的堆内存，所以上述例子中由于buffer1和buffer2数组都不是由常规new运算符创建，所以不能对p3和p4使用delete来释放内存。

定位new函数不可替换，但是可以重载。

###3. 名称空间
#####(1) 传统的C++名称空间
* 声明区域：指可以在其中进行声明的区域。如在函数外面声明全局变量，则对这种变量，其声明区域为其声明所在的文件
* 潜在作用域：变量的潜在作用域从声明点开始，到其声明区域的结尾。因此潜在作用域比声明区域小，这是由于变量必须定义后才能使用
* 然而，变量并非在其潜在作用域内的任何位置都是可见，例如，它可能被另一个在嵌套声明区域中声明的同名变量隐藏。因而变量对程序而言可见的范围被称为作用域

#####(2) 新的名称空间特性
* 名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。所以，默认情况下，在名称空间中声明的名称的链接性是外部的(除非它引用了常量)
* 除了用户定义的名称空间外，还存在另一个名称空间——全局名称空间，它对应于文件级声明区域
* 任何名称空间中的名称都不会与其他名称空间中的名称发生冲突

名称空间是用了关键字namespace创建的，如

    namespace Jill{
        double pail;
        void fetch();
        int pa;
        struct well{...};
    }
访问给定名称空间中的名称时，最简单的方法是通过作用域解析运算符::，如Jill::pail

包含名称空间的名称称为限定的名称

* using声明：由被限定的名称和其前面的关键字using组成，如`using Jill::pail;`。using声明将特定的名称添加到它所属的声明区域中
* using编译指令：由名称空间和其前面的关键字using namespace组成，如`using namespace Jill;`。它可以使整个名称空间中的名称都可用
* 使用作用域解析运算符::加名称，如`::pail`，其使用的是程序中的声明的全局变量pail

**using声明和using编译指令的比较**

* 使用了using声明就如同声明了对应的名称一样，如果函数中已经存在某个名称了，则不能用using声明导入相同的名称
* 使用using编译指令则是进行名称解析，使用using编译指令导入一个已经在函数中声明的名称，则局部名称将隐藏名称空间名，但可以使用名称空间名加作用域解析运算符来使用名称空间名，如`Jill::pail`的形式
* 一般使用using声明会更加安全，这是由于它只导入指定的名称，如果该名称与局部名称发生冲突，编译器将发出指示

#####(3) 名称空间的其他特性
* 可以将名称空间进行嵌套
* 可以在名称空间中使用using声明和using编译指令
* using编译指令是可以传递的，例如在名称空间中myth中使用using编译指令导入了另一个名称空间Jill，那么使用`using namespace myth；`相当于导入了myth和Jill两个名称空间
* 可以给名称空间创建别名，如`namespace mv = myth;`
* 函数的声明和定义都必须位于同一个名称空间中






