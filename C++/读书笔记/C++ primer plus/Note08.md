##第10章 对象和类
###1. 抽象和类
#####(1) C++中的类
* 类是一种将抽象转换为用户定义类型的C++工具，它将数据表示和操纵数据的方法组合成一个整洁的包。
* 类规范由两部分组成，类声明和类方法定义
* 关键字private和public描述了对类成员的访问控制，使用类对象的程序都可以直接访问共有部分，但只能通过公有成员函数(或友元函数，参加第11章)来访问对象的私有成员；C++还提供了第三个访问控制关键字protected
* 类设计尽可能将公有接口与实现细节分开。将实现细节放在一起并将它们与抽象分开被称为封装。数据隐藏(将数据放在类的私有部分中)是一种封装，将实现细节隐藏在私有部分中也是一种封装

#####(2) 实现类成员函数
* 定义类成员函数时，使用作用域解析运算符(::)来标识函数所属的类
* 类方法可以访问类的private组件
* 其定义位于类声明中的函数都将自动成为内联函数，也可以在类声明之外定义成员函数，只需要在类实现部分中定义函数时使用inline限定符就可以使其成为内联函数

* 所创建的每个新对象都有自己的存储空间，用于存储其内部变量和类成员；但同一个类的所有对象共享同一组方法，即每种方法只有一个副本。

通常，数据成员被放在私有部分，成员函数被放在公有部分中，典型的类声明的格式如下：

    class className
    {
    private:
        data member declarations
    public:
        member function prototypes
    }
类设计的第一步是提供类声明，第二步是实现类成员函数，可以在类声明中提供函数定义，但通常的做法是单独提供函数定义，在这种情况下，需要使用作用域解析运算符来指出成员函数属于哪个类。

###2. 类的构造函数和析构函数
#####(1) 声明和定义构造函数
* **类构造函数：**专门用于构造新对象、将值赋给它们的数据成员。其名称与类名相同。构造函数是没有声明类型，即没有返回值；其参数名也不能与类成员相同，为避免混乱，一种常见的做法是在数据成员名中使用m_前缀，另一种做法是在成员名中使用后缀_。
* **使用构造函数：**第一种方法是显式地调用构造函数，如`Stock food = Stock("cabbage",250,11.5);`,第二种是隐式地调用构造函数，如`Stock garment("mason",50,2.5);`。
* **默认构造函数：**是在未提供显式初始值时，用来创建对象的构造函数。其用于如`Stock food；`这种声明；默认构造函数是没有参数，因为声明中不包含值。**隐式地调用默认构造函数时，不要使用圆括号。**
* 当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数。当为类定义了默认构造函数后，程序员必须为它提供默认构造函数，否则如`Stock stock1;`这种声明将是不合法的。
* 定义默认构造函数的方式有两种，一是给已有构造函数的所有参数提供默认值；另一种是通过函数重载来定义另一个构造函数——一个没有参数的构造函数，如`Stock();`
* 由于只有一个默认构造函数，因此不要同时使用上述两种方式。实际上，通常应初始化所有的对象，以确保所有成员一开始就有已知的合理值。

* 在C++11中可以将列表初始化语法用于类

#####(2) 析构函数
* 在对象过期后，程序将自动调用一个特殊的成员函数——析构函数，它会完成清理工作。例如，如果构造函数使用new来分配内存，则析构函数将使用delete来释放这些内存。
* 析构函数是在类名加上~，如Stock类的析构函数为~Stock()；析构函数也是可以没有返回值和声明类型；如果程序员没有提供析构函数，编译器将隐式地声明一个默认析构函数。

#####(3) 小结
**const成员函数**

可以在创建对象时，使用const，如`const Stock stock;`但是使用const后，必须保证函数不会修改调用对象，所以对于如`void show()`没有任何参数的方法，无法将参数声明为const引用或指向const的指针来解决，C++的解决方法是将const关键字放在函数的括号后面，如`void show() const;`

* 接受一个参数的构造函数允许使用赋值语法将对象初始化为一个值，如`Classname object = value;`这种特性可能导致问题，在第11章将介绍关闭这种特性的方法
* 如果构造函数使用了new，则必须提供使用delete的析构函数

###3. this指针
* this指针指向用来调用成员函数的对象。
* 每个成员函数(包括构造函数和析构函数)都有一个this指针，this指针指向调用对象。
* 如果方法需要引用整个调用对象，可以使用*this，而在函数括号后面使用const限定符将this限定为const，这样将不能使用this来修改对象的值。
* this是对象的地址，*this才是指向对象本身。

###4. 对象数组
* 声明对象数组与声明标准类型数组相同：`Stock mystuff[4];`。
* 可以用构造函数来初始化数组元素，在这种情况下，必须为每个元素调用构造函数。如果类包含多个构造函数，则可以对不同的元素使用不同的构造函数。
* 初始化对象数组的方案是，首先使用默认构造函数创建数组元素，然后花括号中的构造函数将创建临时对象，然后将临时对象的内容复制到相应的元素中。**因此，要创建类对象数组，则这个类必须有默认构造函数。**

###5. 类作用域
* 在类中定义的名称(如类数据成员和类成员函数)的作用域为整个类，作用域为整个类的名称只在该类中是已知的，在类外是不可知的。因此，可以在不同类中使用相同的类成员名而不会引起冲突。
* 类作用域意味着不能从外部直接访问类的成员，公有成员函数也是如此，要调用公有成员函数，必须通过对象。

#####(1) 作用域为类的常量
要在类中声明一个常量成员，不能直接如常规声明常量`const int Months = 12;`,因为声明类只是描述了对象的形式，并没有创建对象，在没有创建对象前，将没有用于存储值的空间。有两种方式可以实现这个目标，并且效果相同。

* 第一种方式是在类中声明一个枚举，如`enum {Months = 12};`在类声明中声明的枚举的作用域为整个类。
* 注意，用这种方式声明枚举并不会创建类数据成员，也就是说，所有对象中都不包含枚举，这里的Months只是一个符号名称，在作用域为整个类的代码中遇到它，编译器将用12来替换它。

* 第二种方式是使用关键字static，如`static const int Months = 12;`该常量将与其它静态常量存储在一起，而不是存储在对象中。

#####(2) 作用域内枚举
* 传统的枚举存在一些问题，其中之一是两个枚举定义中的枚举量可能发生冲突，如`enum egg {Small, Medium, Jumbo};` 和 `enum t_shirt {Small, Medium, Xlarge};`,对于egg Small和t_shirt Small位于相同的作用域内，它们将发生冲突。
* 在C++11中提供了一种新枚举，其枚举量的作用域为类，其声明如`enum class egg {Small, Medium, Jumbo};`，这里可以用关键字struct代替class
* 但这种方式需要使用枚举名来限定枚举量，如`egg choice = egg::Small;`


