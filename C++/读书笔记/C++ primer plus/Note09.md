##第11章 使用类
###1. 运算符重载
* C++允许将运算符重载拓展到用户定义的类型。
* 要重载运算符，需使用被称为运算符函数的特殊函数形式，如`operatorop(argument-list)`,具体例如`operator+()`重载+运算符，这里的op必须是有效的C++运算符，不能虚构一个新的符号。
* 不要返回指向局部变量或临时对象的引用，因为函数执行完毕后，局部变量和临时对象将消失，引用将指向不存在的数据。

**重载限制**

(1) 重载后的运算符必须至少一个操作数是用户定义的类型，这将防止用户为标准类型重载运算符。因此，不能将减法运算符(-)重载为计算两个double值的和，而不是它们的差；

(2) 使用运算符时不能违反运算符原来的句话规则，如不能将求模运算符(%)重载成使用一个操作数；同样，不能修改运算符的优先级；

(3) 不能创建新的运算符；

(4) 不能重载下面的运算符：

* sizeof:sizeof运算符
* .：成员运算符
* .*: 成员指针运算符
* :: ： 作用域解析运算符
* ？: ： 条件运算符
* typeid：一个RTTI运算符
* const_cast：强制类型转换运算符
* dynamic_cast：强制类型转换运算符
* reinterpret_cast：强制类型转换运算符
* static_cast：强制类型转换运算符

(5) 其他大多数运算符都可以通过成员或非成员函数进行重载，但下面的运算符只能通过成员函数进行重载。

* =：赋值运算符
* ()：函数调用运算符
* []：下标运算符
* ->：通过指针访问类成员的运算符

###2. 友元
* 友元有3种，分别是友元函数、友元类和友元成员函数。
* 通过将函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限，本章节介绍友元函数，其他两种友元将在第15章介绍。

#####(1) 创建友元
* 创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字friend,如`friend Time operator*(double m, const Time & t);`
* 在编写函数定义时，不需要加上类名的限定符，也不用加关键字friend，只需如同常规函数一样定义即可。
* 应将友元函数看做类的拓展接口的组成部分，只有类声明可以决定哪一个函数是友元，类方法和友元至少表达类接口的两种不同机制。

#####(2) 常用的友元：重载<<运算符
重载形式如下：

    ostream & operator<<(ostream & os, const c_name & obj){
        os << ...;
        return os;
    }
重载<<运算符后就可以实现如`cout << obj << "...";`的操作。

###3. 重载运算符：作为成员函数还是非成员函数
* 一般来说，非成员函数应是友元函数，这样它才能直接访问类的私有数据。
* 非成员版本的重载运输符所需的形参数目和运算符使用的操作数相同，而成员版本所需的参数数目则少一个，因为其中的一个操作数是被隐式地传递的调用对象。

* 如果方法通过计算得到一个新的类对象，则应考虑是否可以使用类构造函数来完成这种工作，这样做不仅可以避免麻烦，而且可以确保新的对象时按照正确的方式创建的。

###4. 类的自动转换和强制类型转换
* 只有接受一个参数的构造函数才能作为转换函数，如Stonewt类有一个只接受一个参数的构造函数`Stonewt::Stonewt(double lbs);`,则可以实现如`Stonewt myCat = 19.2;`。这种转换称为隐式转换，因为它是自动进行的，不需要显式强制类型转换。
* C++新增关键字explicit可以用于关闭这种特性，即如`explicit Stonewt(double lbs);`这样声明构造函数，就不能实现上述操作，只能显式转换，如`mycat = (Stonewt) 19.2;`或者`mycat = Stonewt(19.2);`

* 构造函数只用于从某种类型到类的类型的转换，要进行相反的转换，必须使用特殊的C++运算符函数--转换函数，转换函数的形式是`operator typeName();`
* 转换函数必须是类方法，不能指定返回类型，不能有参数。例如转换为double类型的函数的原型如`operator double();`

* 当类定义了两种或更多的转换时，仍可以用显式强制类型转换来指出要使用哪个转换函数。
* 如果定义了一个typeName的转换函数，当将类对象赋给typeName变量或将其强制转换为typeName类型时，该类型的转换函数将自动被调用。
* C++98中是不能将关键字explicit用于转换函数的，但在C++11中取消了这种限制，就可以使用这个关键字避免隐式转换，另一种避免隐式转换的方法是用一个功能相同的非转换函数替换该转换函数。
* 应该谨慎地使用隐式转换函数，通常，最好选择仅在被显式地调用时才会执行的函数。



