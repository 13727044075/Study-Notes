##第12章 类和动态内存分配
###1. 动态内存和类
* 静态类成员有个特点：无论创建了多少对象，程序都只创建一个静态类变量副本，即类的所有对象共享同一个静态成员。
* 静态类成员不能在类声明中初始化，因为类声明仅仅描述了如何分配内存，但并不分配内存；可以在类声明之外使用单独的语句进行初始化，初始化不需要使用关键字static，但使用作用域运算符，一般在包含类方法的文件中初始化。
* 当静态数据成员是const整数类型或枚举型时，可以在类声明中初始化。
* 字符串是单独保存在堆内存中，对象仅保存了指出到哪里去查找字符串的信息。

在没有定义的情况下，C++自动提供以下这些成员函数：

 * 默认构造函数
 * 默认析构函数
 * 复制构造函数
 * 赋值运算符
 * 地址运算符

#####(1) 复制构造函数
* 复制构造函数用于将一个对象复制到新创建的对象中。即它用于初始化过程中，而不是常规的赋值过程，其原型通常如`Class_name(const Class_name &);`
* 每当程序生成了对象副本时，编译器都将使用复制构造函数，具体地说，当函数按值传递对象或函数返回对象时，都将使用复制构造函数；此外，编译器生成临时对象时，也使用复制构造函数。
* 默认的复制构造函数逐个复制非静态成员(成员复制也称为浅复制)，复制的成员的值。
* 复制构造函数应当复制字符串并将副本的地址赋给对应的类成员，而不仅仅是复制字符串地址，这样每个对象都有自己的字符串，而不是引用另一个对象的字符串，这样调用析构函数时都将释放不同的字符串，而不是试图去释放已经被释放的字符串，**所以必须定义一个显式复制构造函数，特别是类成员中有使用new初始化的、指向数据的指针，而不是数据本身。**

#####(2) 赋值运算符
* C++允许类对象赋值，这是通过自动为类重载赋值运算符实现的，其原型如`Class_name & Class_name::operator=(const Class_name &);`
* 在将已有的对象赋给另一个对象时，将使用重载的赋值运算符；初始化对象时，并不一定会用赋值运算符。
* 定义一个赋值运算符，首先函数应使用delete[]来释放使用new初始化的数据成员，其次函数应当避免将对象赋给自身，最后，函数返回一个指向调用对象的引用。

代码例子如下，假设为StringBad类编写赋值运算符：

    StringBad & StringBad::operator=(const StringBad & st)
    {
        if(this == &st)
            return *this;
        delete [] str;
        ...
        return *this;
    }
代码首先检查自我复制，这是通过查看赋值运算符右边的地址(&st)是否与接收对象(this)的地址相同来完成的。

#####(3) 静态类成员函数
* 可以将成员函数声明为静态的(函数声明必须包含关键字static，但如果函数定义时独立的，则其中不能包含关键字static，类似静态数据成员)
* 这样做，首先，不能通过对象调用静态成员函数，实际上，静态成员函数甚至不能使用this指针；如果静态成员函数是在公有部分声明的，则可以使用类名和作用域解析运算符来调用它；
* 其次，静态成员函数只能使用静态数据成员

###2. 在构造函数中使用new时应注意的事项
* 如果在构造函数中使用**new**来初始化指针成员，则应在析构函数中使用**delete**。
* **new**和**delete**必须相互兼容。**new**对应于**delete**，**new[]**对应于**delete[]**。
* 如果有多个构造函数，则必须以相同的方式使用**new**，要么都带中括号，要么都不带。**因为只有一个析构函数，所有的构造函数都必须与它兼容。**但是，可以在一个构造函数中使用**new**初始化指针，而在另一个构造函数中将指针初始化为空(0或C++11中的nullptr),这是因为**delete**(无论是带中括号或不带中括号)可以用于空指针。
* 应该定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象。通常这种构造函数和下面类似。

具体地说，复制构造函数应分配足够的空间来存储复制的数据，并复制数据，而不仅仅是数据的地址，另外还应该更新所有受影响的静态类成员。

    String::String(const String & st)
    {
        num_strings++;      // 处理静态类成员，这里是令其加一
        len = st.len;       // 获取要复制的string字符串的长度
        str = new char [len + 1];   // 分配空间
        std::strcpy(str, st.str);   // 复制数据
    }

* 应当定义一个赋值运算符，通过深度复制将一个对象复制给另一个对象。

具体地说，这个方法应完成这些操作：检查自我赋值的情况，释放成员指针以前指向的内存，复制数据而不仅仅是数据的地址，并返回一个指向对象的引用。该类方法与下面类似：

    String & String::operator=(const String & st)
    {
        if (this == &st)
            return *this;   // 如果是自我赋值，就直接返回本身的引用
        delete [] str;      // 释放成员指针以前指向的内存
        len = st.len;       // 获取要复制的string字符串的长度
        str = new char [len + 1];   // 分配空间
        std::strcpy(str, st.str);   // 复制数据
        return *this;       // 返回一个指向调用对象的引用
    }

* 默认的逐成员复制和赋值行为有一定的智能，它可以使用成员类型定义的复制构造函数和赋值运算符。

###3. 有关返回对象的说明
* 当成员函数或独立的函数返回对象时，可以返回指向对象的引用、指向对象的const引用或const对象。
* 返回对象将调用复制构造函数，而返回引用不会。
* 两种常见的返回非const对象的情形是，重载赋值运算符以及重载与cout一起使用的<<运算符。前者是旨在提高效率，后者是必须这样做。
* 如果被返回的对象是被调用函数中的局部变量，则不应按引用方式返回它，因为在被调用函数执行完毕时，局部对象将调用其析构函数。因此当控制权回到调用函数时，引用指向的对象将不再存在。这种情况下，应返回对象而不是引用。**通常，被重载的算术运算符属于这一类。**
* 如果方法或函数要返回局部对象，则应返回对象，这种情况下，将使用**复制构造函数**来生成返回的对象；
* 如果方法或函数要返回一个没有公有复制构造函数的类(如ostream类)的对象，它必须返回一个指向这种对象的引用；
* 最后，如果有些方法和函数(如重载的赋值运算符)可以返回对象，也可以返回指向对象的引用，这种情况下，应该首选引用，因为其效率高。

###4. 使用指向对象的指针
* 使用new来初始化对象，使用如`Class_name * pclass = new Class_name(value);`格式的语句，它将调用如`Class_name(Type_name)`的构造函数(Type_name是value的类型)。
* 使用对象指针，还可以用常规表示法来声明，如`String * glamour;`,也可以将指针初始化为指向已有的对象，如`String * first = &sayings[0];`(这里的sayings是一个String类数组)；
* 对类使用new将调用相应的类构造函数来初始化新创建的对象，如`String * gleep = new String;`会调用默认构造函数；
* 可以使用->运算符通过指针访问类方法，如`first->length();`
* 可以对对象指向应用**解除引用运算符(\*)**来获得对象；

**成员初始化列表**

对于const数据成员，必须在执行到构造函数体之前，即创建对象时进行初始化，C++提供了成员初始化列表的方法来完成这个工作。

成员初始化列表由逗号分隔的初始化列表组成，前面带冒号。例子如下：

    String::String(int qz) : qsize(qs)
    {
        ...
    }
这里的qsize是String类的const数据成员

只有构造函数可以使用这种初始化列表语法，对于const类成员和被声明为引用的类成员，都必须使用这种语法，因为引用和const数据类型，都是只能在被创建是进行初始化。

C++11允许以更直观的方式进行初始化，即类内初始化，如下所示：

    class Classy
    {
        int mem1 = 10;
        const int mem2 = 20;
    // ...
    }
这等价于在构造函数中使用成员初始化列表`Classy::Classy() : mem1(10), mem2(20) {...}`

如果调用了使用成员初始化列表的构造函数，这种情况下，实际列表将覆盖这些默认初始值。

