##第13章 类继承
###1. 基类
* 从一个类派生出另一个类时，原始类称为基类，继承类称为派生类。
* 派生类的声明方式如`class RatedPlayer : public TableTennisPlayer{};`，`TableTennisPlayer`是一个基类，而`RatedPlayer`是继承这个基类的派生类，这种声明表示这是公有派生。
* 使用公有派生，基类的公有成员将成为派生类的公有成员；基类的私有部分也将称为派生类的一部分，但只能通过基类的公有和保护方法访问。
* 派生类构造函数必须使用基类的构造函数，并且应通过成员初始化列表将基类信息传递给基类构造函数，然后再初始化派生类新增的数据成员。
* 在释放对象时，与创建对象的顺序相反，首先调用派生类的析构函数，然后自动调用基类的析构函数。

**派生类和基类之间的特殊关系**

* 派生类对象可以使用基类的方法，条件是不是私有的
* 基类指针可以在不进行显式类型转换的情况下指向派生类对象；基类引用可以在不进行显式类型转换的情况下引用派生类对象。但是这是单向的，反过来，不能将基类对象和地址赋给派生类引用和指针。
* 基类指针或引用虽然可以指向或引用派生类对象，但只能调用基类方法，无法调用派生类的方法。
* 基类引用定义的函数或指针参数可以用于基类对象或派生类对象，引用兼容性还可以将基类对象初始化为派生类对象。

###2. 继承：is-a 关系
* C++有3种继承方式：公有继承、保护继承和私有继承。
* 公有继承是最常用的方式，它建立一种`is-a`关系，即派生类对象也是一个基类对象，可以对基类对象执行的任何操作，也可以对派生类对象执行。

###3. 多态公有继承
* 当同一个方法在派生类和基类中的行为是不同的，即方法的行为应取决于调用该方法的对象，这称为多态——具有多种形态，即同一个方法的行为随上下文而异。
* 有两种重要机制可以用于实现多态公有继承：在派生类中重新定义基类的方法和使用虚方法。
* 虚方法是在声明时加上关键字`virtual`的方法，经常在基类中将派生类会重新定义的方法声明为虚方法。方法在基类中被声明为虚后，它在派生类中将自动成为虚方法，但在派生类声明中使用`virtual`关键字指出哪些函数是虚函数也是一个好方法。
* 使用虚方法的原因是，如果方法是通过引用或指针而不是对象调用的，它将确定使用哪一种方法。没有使用关键字`virtual`,程序将根据引用类型或指针类型选择方法，但如果使用了，程序将根据引用或指针指向的对象的类型来选择方法。
* 使用虚析构函数可以确保正确的析构函数序列被调用，因为如果析构函数不是虚的，则将只调用对应于指针类型的析构函数。

###4. 静态联编和动态联编
* 将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编(binding)。
* 在编译过程中进行联编被称为静态联编，又称为早起联编。
* 而编译器必须生成能够在程序运行时选择正确的虚方法的代码，这被称为动态联编。

#####(1) 指针和引用类型的兼容性
* C++中，动态联编与通过指针和引用调用方法相关，从某种程度上说，这是由继承控制的。
* 将派生类引用或指针转换为基类引用或指针被称为**向上强制转换**，这使得公有继承不需要进行显式类型转换，这个规则是`is-a关系`的一部分。
* 相反的过程，将基类引用或指针转换为派生类引用或指针被称为**向下强制转换**，如果不使用显式类型转换，则这种行为是不允许的。原因是is-a关系通常是不可逆转的，派生类可以新增数据成员，而使用这些数据成员的类成员函数是不能应用于基类的。
* 隐式向上强制转换使基类指针或引用可以指向基类对象或派生类对象，因此需要动态联编。

#####(2) 虚成员函数和动态联编
* 编译器对非虚方法使用静态联编。
* 静态联编的效率更高，因此被设置为C++的默认选择。
* 编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针，这种数组称为虚函数表，虚函数表中存储了为类对象进行声明的虚函数的地址。
* 使用虚函数时，在内存和执行速度方面有一定的成本，包括

    * 每个对象都将增大，增大量为存储地址的空间
    * 对于每个类，编译器都创建一个虚函数地址表(数组)
    * 对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址

#####(3) 有关虚函数的注意事项
* 构造函数不能是虚函数；
* 析构函数应当是虚函数，除非类不用做基类；所以通常应当给基类提供一个虚析构函数，即使它并不需要析构函数；
* 友元不能是虚函数，因为友元不是类成员，而只有成员才能是虚函数；
* 重新定义继承的方法并不是重载，会隐藏方法，所以，如果重新定义继承的方法，应确保与原来的原型完全相同，**但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针，这种特性被称为返回类型协变**；其次，**如果基类声明被重载了，则应在派生类中重新定义所有的基类版本**。

###5. 访问控制：protected
* 关键字protected与private相似，在类外只能用公有类成员来访问protected部分中的类成员；其区别只有在基类派生的类中才会表现出来，**派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员**。
* 但最好对类数据成员采用私有访问控制，不要使用保护访问控制；同时通过基类方法使派生类能够访问基类数据。
* 对于成员函数，保护访问控制很有用，它可以让派生类能够访问公众不能使用的内部函数。

###6. 抽象基类(abstract base class,ABC)
* C++通过使用纯虚函数提供未实现的函数，纯虚函数声明的结尾处为**=0**，如`virtual double Area() const = 0;`
* 当类声明中包含纯虚函数时，则不能创建该类的对象，即包含纯虚函数的类只用作基类。
* 要成为真正的抽象基类(ABC),必须至少包含一个纯虚函数。
* C++允许纯虚函数有定义，当然也可以不定义。

###7. 继承和动态内存分配
在基类使用动态内存分配的情况下，其类声明中必须包含构造函数使用new时的特殊方法：**析构函数、复制构造函数和重载赋值运算符**，对于派生类，有两种情况：

(1) 派生类不使用new：不需要为其定义上述三种特殊方法。

* 对于析构函数，如果没有定义析构函数，编译器将定义一个不执行任何操作的默认析构函数，而派生类的析构函数总是要执行一些操作：执行自身的代码后调用基类析构函数。
* 对于复制构造函数，成员复制将根据数据类型采用相应的复制方式，在复制类成员或继承的类组件时，则是使用该类的复制构造函数完成的，因此派生类的默认复制构造函数会使用基类的显式复制构造函数来复制派生类对象中的基类数据成员。
* 对于赋值来说，也是如复制构造函数一样，类的默认赋值运算符将自动使用基类的赋值运算符来对基类组件进行赋值。

(2) 派生类使用new：必须定义上述三种特殊方法

* 析构函数，由于派生类析构函数会自动调用基类析构函数，所以派生类的析构函数的职责是对其构造函数执行工作的进行清理，即只需要释放派生类中使用new的数据成员即可；
* 复制构造函数，派生类的复制构造函数必须调用基类的复制构造函数来处理基类的数据，并且使用**成员初始化列表**调用基类的复制构造函数
* 对于赋值运算符，需要显式调用基类赋值运算符，并且需要使用作用域解析运算符来显式调用基类的赋值运算符。

此外，对于派生类如何使用基类的友元，需要使用**强制类型转换**，以便匹配原型时能够选择正确的函数，如在派生类hasDMA中使用基类baseDMA的友元例子如下：

    std::ostream & operator<<(std::ostream & os, const hasDMA & hs)
    {
        os << (const baseDMA &) hs;
        ...
        return os;
    }
上述代码第一行显示了如何使用基类的友元。


