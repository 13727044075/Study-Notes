##第13章 类继承
###1. 基类
* 从一个类派生出另一个类时，原始类称为基类，继承类称为派生类。
* 派生类的声明方式如`class RatedPlayer : public TableTennisPlayer{};`，`TableTennisPlayer`是一个基类，而`RatedPlayer`是继承这个基类的派生类，这种声明表示这是公有派生。
* 使用公有派生，基类的公有成员将成为派生类的公有成员；基类的私有部分也将称为派生类的一部分，但只能通过基类的公有和保护方法访问。
* 派生类构造函数必须使用基类的构造函数，并且应通过成员初始化列表将基类信息传递给基类构造函数，然后再初始化派生类新增的数据成员。
* 在释放对象时，与创建对象的顺序相反，首先调用派生类的析构函数，然后自动调用基类的析构函数。

**派生类和基类之间的特殊关系**

* 派生类对象可以使用基类的方法，条件是不是私有的
* 基类指针可以在不进行显式类型转换的情况下指向派生类对象；基类引用可以在不进行显式类型转换的情况下引用派生类对象。但是这是单向的，反过来，不能将基类对象和地址赋给派生类引用和指针。
* 基类指针或引用虽然可以指向或引用派生类对象，但只能调用基类方法，无法调用派生类的方法。
* 基类引用定义的函数或指针参数可以用于基类对象或派生类对象，引用兼容性还可以将基类对象初始化为派生类对象。

###2. 继承：is-a 关系
* C++有3种继承方式：公有继承、保护继承和私有继承。
* 公有继承是最常用的方式，它建立一种`is-a`关系，即派生类对象也是一个基类对象，可以对基类对象执行的任何操作，也可以对派生类对象执行。

###3. 多态公有继承
* 当同一个方法在派生类和基类中的行为是不同的，即方法的行为应取决于调用该方法的对象，这称为多态——具有多种形态，即同一个方法的行为随上下文而异。
* 有两种重要机制可以用于实现多态公有继承：在派生类中重新定义基类的方法和使用虚方法。
* 虚方法是在声明时加上关键字`virtual`的方法，经常在基类中将派生类会重新定义的方法声明为虚方法。方法在基类中被声明为虚后，它在派生类中将自动成为虚方法，但在派生类声明中使用`virtual`关键字指出哪些函数是虚函数也是一个好方法。
* 使用虚方法的原因是，如果方法是通过引用或指针而不是对象调用的，它将确定使用哪一种方法。没有使用关键字`virtual`,程序将根据引用类型或指针类型选择方法，但如果使用了，程序将根据引用或指针指向的对象的类型来选择方法。
* 使用虚析构函数可以确保正确的析构函数序列被调用，因为如果析构函数不是虚的，则将只调用对应于指针类型的析构函数。

###4. 静态联编和动态联编
* 将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编(binding)。
* 在编译过程中进行联编被称为静态联编，又称为早起联编。
* 而编译器必须生成能够在程序运行时选择正确的虚方法的代码，这被称为动态联编。

#####(1) 指针和引用类型的兼容性
* C++中，动态联编与通过指针和引用调用方法相关，从某种程度上说，这是由继承控制的。
* 将派生类引用或指针转换为基类引用或指针被称为**向上强制转换**，这使得公有继承不需要进行显式类型转换，这个规则是`is-a关系`的一部分。
* 相反的过程，将基类引用或指针转换为派生类引用或指针被称为**向下强制转换**，如果不使用显式类型转换，则这种行为是不允许的。原因是is-a关系通常是不可逆转的，派生类可以新增数据成员，而使用这些数据成员的类成员函数是不能应用于基类的。
* 隐式向上强制转换使基类指针或引用可以指向基类对象或派生类对象，因此需要动态联编。

#####(2) 虚成员函数和动态联编

