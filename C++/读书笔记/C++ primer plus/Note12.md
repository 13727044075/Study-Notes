##第14章 C++中的代码重用
###1. 包含对象成员的类
#####(1) valarray类简介
* valarray类是由头文件valarray支持的，顾名思义，这个类用于处理数值，它支持诸如将数组中所有元素的值相加以及在数组中找出最大和最小的值等操作。
* valarray被定义为一个模板类，以便能够处理不同的数据类型。

模板特性意味着声明对象时，必须指定具体的数据类型。因此，声明对象应如下所示：

    valarray<int> q_values;   // an array of int
    valarray<double> weights; // an array of double

而使用这个类的构造函数的例子如下：

    doulbe gpa[5] = {3.1, 3.2, 3.5, 4.5, 3.9};
    valarray<int> v1;
    valarray<int> v2(8);    // an array of 8 int elements;
    valarray<int> v3(10, 8); // an array of 8 int elements,each set to 10
    // an array of 4 elements initialized to the first 4 elements of gpa
    valarray<double> v4(gpa, 4);   
    // C++11中可以使用初始化列表
    valarray<int> v5 = {20, 23, 27, 5};

这个类包含的一些方法如下：

  * operator\[](): 让你能够访问各个元素
  * size(): 返回包含的元素数
  * sum():  返回所有元素的总和
  * max():  返回最大的元素
  * min():  返回最小的元素

#####(2) 接口和实现
* 使用公有继承时，类可以继承接口，可能还有实现(基类的纯虚函数提供接口，但不提供实现)。获得接口是`is-a`关系的组成部分。
* 而使用组合，类可以获得实现，但不能获得接口，不继承接口是`has-a`关系的组成部分。

C++包含让程序员能够限制程序结构的特性——使用`explicit`防止单参数构造函数的隐式转换，使用`const`限制方法修改数据，等等。这样做的根本原因是：**在编译阶段出现错误优于在运行阶段出现错误**。

* 使用成员初始化列表来初始化被包含的对象，初始化的顺序是它们被声明的顺序，而不是它们在初始化列表中的顺序。

###2. 私有继承
* 私有继承也是一种`has-a`关系。使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员，这意味着基类方法不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中使用它们。
* 关于接口问题，公有继承是基类的方法称为派生类的公有方法，也就是派生类将继承基类的接口，这是`is-a`关系的一部分；而私有继承，基类的公有方法将称为派生类的私有方法，也就是派生类不继承基类的接口。
* 包含是将对象作为一个命名的成员对象添加到类中，而私有继承将对象作为一个未被命名的继承对象添加到类中。术语**子对象**表示通过继承或包含添加的对象。

#####(1) 使用私有继承
* 使用私有继承要使用关键字`private`，如`class Student : private std::string, private std::valarray<double>`，并且这种使用多个基类的继承被称为**多重继承**
* 初始化基类组件也是使用成员初始化列表，但不同于包含可以有成员名，私有继承是使用类名，如`Student(const char * str, const double * pd, int n) : std::string(ptr),std::valarray<double>(pd,n) {}`
* 访问基类的方法，**包含**是通过使用**对象名**，而**私有继承**是使用**类名和作用域解析运算符**来调用方法。
* 访问基类对象，通过强制类型转换
* 访问基类的友元函数，可以通过显式地转换为基类来调用正确的函数。在私有继承中，未进行显式类型转换的派生类引用或指针，无法赋值给基类的引用或指针。

#####(2) 使用包含还是私有继承
* 包含和私有继承都可以建立`has-a`关系。
* 使用包含，原因是，首先，它易于理解，类声明中包含表示被包含类的显式命名对象，代码可以通过名称引用这些对象，而使用继承将使关系更加抽象；其次，继承会引起很多问题，尤其是从多个基类继承时，可能必须处理很多问题，如包含同名方法的独立的基类或共享祖先的独立基类；另外，包含可以包括多个同类的子对象。
* 使用私有继承，是由于其提供的特性比包含多。私有继承是可以访问保护成员的，但包含则不可以；此外，需要使用私有继承的情况是重新定义虚函数。派生类可以重新定义虚函数，但包含类不能。

#####(3) 保护继承
* 保护继承是私有继承的变体，它是使用关键字protected。
* 使用保护继承，基类的公有成员和保护成员都将成为派生类的保护成员。
* 和私有继承一样，基类的接口在派生类中也是可用的，但在继承层次结构之外是不可以使用的。
* 私有继承和保护继承的主要区别体现在于当从派生类派生出另一个类，如果使用私有继承，第三代类将不能使用基类的接口，因为基类的公有方法在派生类中成为私有方法；但使用保护继承，则基类的方法在第二代类中变成保护方法，第三代类是可以继续使用的。

#####(4) 使用using重新定义访问权限
* 使用私有派生或保护派生时，基类的公有成员将成为私有成员或保护成员。要让基类的方法在派生类外面可以使用，一个方法是定义一个使用该基类方法的派生类方法。
* 另一个方法是将函数调用包装在另一个函数调用中，即使用一个using声明(如同名称空间一样)来指出派生类可以使用特定的基类成员，即使采用的是私有派生。例如，希望使用基类`baseClass`的一个方法min()，可以在派生类声明的`public`部分使用`using baseClass::min;`这个语句，即using声明只用成员名——没有圆括号，函数特征标和返回类型。

###3. 多重继承(MI)
* 公有MI也是is-a关系，必须使用关键字`public`来限定每一个基类，这是因为除非特别指出，否则编译器将认为是私有派生。
* MI可能会带来多个问题，两个主要问题是：从两个不同的基类继承同名方法；从两个或更多相关基类那里继承同一个类的多个实例。

**虚基类**
#####(1) 构造函数
* 使得从多个类(它们的基类相同)派生出的对象只继承一个基类对象。用法是这些被继承的类在继承其基类时，需要添加上关键字`virtual`
* 在基类是虚的时候，C++禁止信息通过中间类自动传递给基类。这个时候，如果不希望默认构造函数来构造基类对象，则必须显式地调用所需的基类构造函数。

#####(2) 使用哪个方法
* 多重继承可能导致函数调用的二义性。如BadDude类可能从Gunslinger类和PokerPlayer类继承两个完全不同的Draw()方法。
* 解决这个二义性的问题的一个方法是，使用作用域解析运算符，如上述例子中可以使用`PokerPlayer::Draw()`表明使用的是PokerPlayer类的方法。但更好的方法是在BadDude类中重新定义Draw()方法，在重新定义的方法中调用想要继承的类的方法。

* 对于单继承，让派生方法调用基类的方法是可以的，例如HeadWaiter类的Show()方法调用了其继承的Waiter类的Show()方法，而Waiter的Show()方法调用了其继承的基类Worker的Show()方法，这种递增的方式只适用于单继承，对于多继承是无效的。
* 解决方法，一种是使用模块化方式，即在上述例子中，分别提供一个只显示基类，第二代类及第三代类组件的方法，然后再使用Show()方法组合这几个方法；
* 第二种方法是将所有的数据组件都设置为保护的，而不是私有的，但使用保护(而不是保护数据)将可以更严格地控制对数据的访问。

#####(3) 混合使用虚基类和非虚基类
* 如果基类是虚基类，派生类将包含基类的一个子对象；如果基类不是虚基类，则派生类将包含多个子对象。
* 如果类从不同的类中继承了两个或多个同名成员(数据或方法)，则使用该成员名时，如果没有用类名进行限定，对于非虚基类，会导致二义性；但对于虚基类，则不一定会导致二义性，在这种情况下，如果某个名称优先于其他所有名称，则使用它时，即使不使用限定符，也不会导致二义性。
* 派生类中的名称优先于直接或间接祖先类中的相同名称。

###4. 类模板
* 模板类以`template <class Type>`开头，这里的class可以替换成关键字`typename`;
* 在模板定义中，可以使用泛型名来标识存储在栈中的类型；同样，可以使用模板成员函数替换原有的类的类方法，也就是在方法定义加上一句`template <class Type>`。
* 如果在类声明中定义了方法(内联定义)，则可以省略模板前缀和类限定符。
* **不能将模板成员函数放在一个独立的实现文件中**。这是因为模板不是函数，它们不能单独编译，模板必须与特定的模板实例化请求一起使用。因此，最简单的方法是**将所有模板信息放在一个头文件中，并在要使用这些模板的文件中包含该头文件**。

* 可以将内置类型或类对象用作类模板，如`Stack<Type>`的类型，对于指针，也是可以作为其类型的。

#####(1) 非类型参数和数组模板
* 使用指针栈的方法之一是，让调用程序提供一个指针数组。
* 模板常用作容器类，它可以使用如`template <class T, int n>`，其中class指出T为类型参数，int指出n的类型为int。这种参数(指定特殊的类型而不是用作泛型名)称为非类型或表达式参数。
* 表达式参数有一些限制，表达式参数可以是整型、枚举、引用或者指针；此外，模板代码不能修改参数的值，也不可以使用参数的地址；
* 表达式参数方法的主要缺点是，每种数组大小都将生成自己的模板；主要优点是其使用的为自动变量维护的内存栈，执行速度将更快，尤其是使用了很多小型数组时。

* 可以递归使用模板。如定义了一个数组模板`ArrayTp<T,n>`,可以如此使用`ArrayTP< ArrayTp<int, 5>, 10> twodee;`,效果等同于二维数组`int twodee[10][5];`,这里注意模板中维的顺序与等价的二维数组相反；
* 模板可以包含多个类型参数。
* 类模板的一个新特性是，可以为类型参数提供默认值，如`template<class T1, class T2 = int> class Topo{ ...};`，可以为类模板类型参数提供默认值，但不能为函数模板参数提供默认值。然而，可以为非类型参数提供默认值，这对于类模板和函数模板都是适用的。

#####(2) 模板的具体化





