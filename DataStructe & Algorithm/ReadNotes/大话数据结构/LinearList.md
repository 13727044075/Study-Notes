## 《大话数据结构》 第三章 线性表

#### 1. 线性表的定义

**==线性表(List): 零个或多个数据元素的有限序列。==**

根据上述定义，可以知道线性表首先是一个序列，也就是说元素之间是有顺序的，若元素存在多个，则第一个元素没有前驱，最后一个元素没有后继，其他每个元素都有且只有一个前驱和后继。

其次，线性表是有限的。

* 线性表元素的个数`n(n>=0)`定义为线性表的长度，当n=0时，称为空表。
* 在较复杂的线性表中，一个数据元素可以由若干个数据项组成。
* 线性表中的数据都必须是同一种数据类型。

#### 2. 线性表的抽象数据类型
定义如下：


```
ADT 线性表(List)

Data
    线性表的数据对象集合为{a1,a2,......,an},每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素都有且只有一个直接后继元素。元素之间的关系是一对一的关系。
    
Operation
    InitList(*L): 初始化操作，建立一个空的线性表L。
    ListEmpty(L): 若线性表为空，返回true，否则返回false。
    ClearList(*L): 清空线性表。
    GetElem(L, i, *e): 将线性表L中的第i个位置的元素值返回给e。
    LocateElem(L,e): 在线性表L中查找与给定值e相等的元素，如果查找成功，返回其序号；否则，返回0表示失败
    ListInsert(*L, i, e): 在线性表L中的第i个位置插入新元素e。
    ListDelete(*L, i, *e): 删除线性表L中的第i个位置的元素，并用e返回其值。
    ListLength(L):  返回线性表L中的元素个数。
```

如果要实现两个线性表集合A和B的并集操作，即使得A = A U B，将存在B中且不存在A中的元素插入到A中即可。

实现的代码如下：

```
/*将所有的在线性表中Lb中但不存在La中的数据元素插入到La中*/
void unionL(List *La, List Lb)
{
    int La_len, Lb_len, i;
    ElemType e;         // 声明与La，Lb相同的数据元素e
    La_len = ListLength(*La);
    Lb_len = ListLength(Lb);
    for(i=0;i<Lb_len;i++)
    {
        GetElem(Lb, i, &e); // 取Lb中第i个元素给e
        if(!LocateElem(*La, e)) // La中不存在和e相同的数据元素
            ListInsert(La, ++La_len, e);
    }
}
```


#### 3.线性表的顺序存储结构

==线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。==

(1) 可以用一维数组来实现线性表的顺序存储结构,结构代码如下：


```
#define MAXSIZE 20  // 存储空间初始分配量
typedef int ElemType;   // ElemType类型根据实际情况而定，这里假设为int
typedef struct
{
    ElemType data[MAXSIZE]; // 数组存储数据元素，最大值为MAXSIZE
    int length;             // 线性表当前长度
}SqList;
```
描述顺序存储结构需要三个属性：
* 存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置；
* 线性表的最大存储容量：数组长度MAXSIZE；
* 线性表的当前长度：length。


(2) 线性表中第1个元素的存储位置和第i个元素的存储位置满足下列关系(LOC表示获得存储位置的函数，c表示数据元素的数据类型所占据的存储单元): `LOC(ai) = LOC(a1) + (i-1) * c`

#### 4. 顺序存储结构的插入与删除

(1) 获得元素操作

代码如下：

```
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
typedef int Status;
/* Status 是函数的类型，其值是函数结构状态代码，如OK等*/
/* 初始条件：顺序线性表L已存在，1<= i <= ListLength(L) */
/* 操作结果：用e返回L中第i个数据元素的值*/

Status GetElem(SqList L, int i, ElemType *e)
{
    if(L.length == 0 || i < 1 || i >L.length)
        return ERROR;
    *e = L.data[i-1];
    return OK;
}
```

(2) 插入操作

插入算法的思路如下：

* 如果插入位置不合理，抛出异常；
* 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；
==* 从最后一个元素向前遍历到第i个位置，分别将它们都向后移动一个位置；==
* 将要插入元素填入位置i处；
* 表长加1.

(3) 删除操作

思路如下：

* 如果删除位置不合理，抛出异常；
* 取出删除元素；
==* 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；==
* 表长减一。

(4) 优缺点


优点 | 缺点
---  |---
* 无须为表示表中元素之间的逻辑关系而增加额外的存储空间| * 插入和删除操作需要移动大量元素，其时间复杂度是`O(n)`
* 可以快读地存取表中任一位置的元素，时间复杂度`O(1)`  | * 当线性表长度变化较大时，难以确定存储空间的容量,会造成存储空间的"碎片"

代码例子--[顺序线性表](https://github.com/ccc013/Study-Notes/blob/master/DataStructe%20%26%20Algorithm/CodeExample/LinearList_Order.md)


#### 5. 线性表的链式存储结构

  在链式结构中，除了要存储数据元素信息外，还有存储它的后继元素的地址。我们把存储数据元素信息的域称为数据域，把存储直接后继元素位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素的存储映像，称为结点。
  
  n个结点链结成一个链表，即为线性表的链式存储结构，因为此链表的每一个结点中只包含一个指针域，所以叫做单链表。
  
  我们把链表中第一个结点存储的位置叫做头指针，而最后一个结点指针为空。有时候，为了更方便地对链表进行操作，会在单链表的第一个结点前设一个结点，称为头结点。头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息，其指针域存储指向第一个结点的指针。
  
(1) 链式存储结构代码描述


```
typedef struct Node
{
    ElemType data;
    struct Node * data;
} Node;
typedef struct Node* LinkList;  // 头指针
```

(2) 读取操作

获得链表第i个元素的算法思路：

* 声明一个指针p指向链表第一个结点，初始化j从1开始；
* 当j<i时，遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；
* 若到链表末尾p为空，则说明第i个结点不存在；
* 否则查找成功，返回结点p的数据。


(3) 插入操作

* 声明一个指针p指向链表第一个结点，初始化j从1开始；
* 当**j<i-1**时，遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；（书中是写j<i，但是我实际敲代码发现应该是小于`i-1`才是正确的，因为要找到第`i-1`个结点，书中的例子达到的效果是插入到第`i+1`的位置，而不是第`i`个位置）
* 若到链表末尾p为空，则说明第i个结点不存在；
* 否则查找成功，在系统中生成一个空结点s;
* 将数据元素e赋值给`s->data`;
==* 单链表的插入标准语句`s->next = p->next; p->next = s;`;==
* 返回成功。

(4) 删除操作

* 声明一个指针p指向链表第一个结点，初始化j从1开始；
* 当**j<i-1**时，遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；（跟插入操作一样）
* 若到链表末尾p为空，则说明第i个结点不存在；
* 否则查找成功，将欲删除的结点`p->next`赋值给`q`；
* 单链表的删除标准语句`p->next = q->next`;
* `*e = q->data`,返回被删除元素的数据；
* 释放`q`结点，返回成功。

(5) 整表创建


* 声明一指针`p`和计数器变量`i`;
* 初始化一个空链表L；
* 让L的头结点的指针指向`NULL`，即建立一个带头结点的单链表；
* 循环：
    * 生成一个新结点赋值给`p`;
    * 随机生成一个数字赋值给`p->data`；
    * 将`p`插入到头结点与前一个新结点之间。(头插法）

另一种方法是尾插法，在开始的时候声明多一个指针`r`，让其指向尾部的结点，在循环中，执行`r->next = p; r = p;`，即保持`r`指向尾部结点。

(6) 清空链表

* 声明一结点`p`和`q`；
* 将第一个结点赋给`p`;
* 循环：
    * 将下一个结点赋值给`q`;
    * 释放`p`；
    * 将`q`赋值给`p`.

(7) 单链表和顺序存储结构的对比

* 对于顺序存储结构，查找的时间性能是O(1),而插入和删除操作需要平均移动表长一半的元素，时间为O(n);
* 对于单链表，查找的时间是O(n),而插入和删除操作的时间是O(1).


代码例子--[单链表](https://github.com/ccc013/Study-Notes/blob/master/DataStructe%20%26%20Algorithm/CodeExample/LinkList.md)

#### 6. 静态链表

    用数组表示的链表叫做静态链表。数组的元素都是由两个数据域组成，data和cur。前者用于存储数据，而后者相当于单链表中的next指针，存放该元素的后继在数组中的下标，因此也叫cur为游标。


线性表的静态链表存储结构
```
#define MAXSIZE 1000    // 假设链表的最大长度是1000
typedef struct
{
    ElemType data;
    int cur;
} Component, StaticLinkList[MAXSIZE];
```

  另外，数组的第一个和最后一个元素作为特殊元素处理，不存数据，我们通常把未被使用的数组元素称为备用链表。**而数组第一个元素，即下标为0的元素的cur就存放备用链表的第一个结点的下标；而数组最后一个元素的cur则存放第一个有数值得元素的下标，相当于单链表中的头结点作用，当整个链表为空时，则是0。**
  
根据书上给的代码写出的例子在这:[StaticLinkList](https://github.com/ccc013/Study-Notes/blob/master/DataStructe%20%26%20Algorithm/CodeExample/StaticLinkList.md) 


#### 7. 循环链表

    将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成了一个环，这种头尾相接的单链表称为但循环链表，简称循环链表(circular linked list)。

    单链表和循环链表的主要差异就在于循环的判断条件上，原来是判断`p->next`是否为空，现在是`p->next`不等于头结点，则循环未结束。
    
    循环链表中如果使用指向终端结点的尾指针`rear`表示，那么此时查找开始结点和终端结点都是O(1)，因为终端结点用指针`rear`表示，而开始结点就是`rear->next->next`。
    
    如果要合并两个循环链表A和B，其分别有尾指针`rearA`，`rearB`，则可以如下操作
    
    
```
p = rearA->next;    // 保存A表的头结点
rearA->next = rearB->next->next;    // 将本是B表的第一个结点（非头结点）赋值给rearA->next
q = rearB->next;
rearB->next = p;
free(q);    // 释放B表的头结点
```

#### 8. 双向链表

    双向链表(double linked list) 是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。

双向链表的存储结构

```
typedef struct DulNode
{
    ElemType data;
    struct DuLNode* prior;
    struct DuLNode* next;
}DulNode, *DuLinkList;
```

代码例子---[循环的双向链表](https://github.com/ccc013/Study-Notes/blob/master/DataStructe%20%26%20Algorithm/CodeExample/DulLinkList.md)
















