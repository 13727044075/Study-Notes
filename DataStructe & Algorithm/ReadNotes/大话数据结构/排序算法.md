### 排序算法

这是《大话数据结构》第九章排序算法的知识点总结。

#### 排序的基本概念与分类

> 假设含有n个记录的序列为${r_1,r_2,\cdots,r_n}$，其相应的关键字分别为${k_1,k_2,\cdots,k_n}$，需要确定$1,2, \cdots, n$的一种排列$p_1,p_2,\cdots,p_n$，使其相应的关键字满足$k_{p1}\le k_{p2}\le \cdots \le k_{pn}$非递减（或非递增）关系，即使得序列成为一个按关键字有序的序列${r_{p1}, r_{p2}, \cdots, r_{pn}}$，这样的操作就称为排序。

**在排序问题中，通常将数据元素称为记录。**

排序的依据是关键字之间的大小关系，那么，对同一个记录集合，针对不同的关键字进行排序，可以得到不同序列。

这里关键字$k_i$可以是记录$r$的主关键字，也可以是次关键字，甚至是若干数据项的组合。

##### 排序的稳定性

由于排序不仅是针对主关键字，还有针对次关键字，因为待排序的记录序列中可能存在两个或两个以上的关键字相等的记录，排序结果可能会存在不唯一的情况，下面给出稳定与不稳定排序的定义。

> 假设$k_i = k_j \ (1\le i \le n, 1\le j\le n, i\neq j)$，且在排序前的序列中$r_i$领先于$r_j$（即$i \lt j$）。如果排序后$r_i$仍领先于$r_j$，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中$r_j$领先于$r_i$，则称所用的排序方法是不稳定的。

不稳定的排序算法有：**希尔、快速、堆排和选择排序**。

##### 内排序和外排序

根据在排序过程中待排序的记录是否全部被放置在内存中，排序可以分为：内排序和外排序。

> 内排序是在排序整个过程中，**待排序的所有记录全部被放置在内存中**。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要**在内外存之间多次交换数据才能进行**。

对于内排序来说，排序算法的性能主要是受到3个方面的影响：

###### 时间性能

在内排序中，主要进行两种操作：**比较和移动**。高效率的内排序算法应该是具有尽可能少的关键字比较次数和尽可能少的记录移动次数。

###### 辅助空间

辅助存储空间是除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间。

###### 算法的复杂性

这里指的是算法本身的复杂度，而不是算法的时间复杂度。



根据排序过程中借助的主要操作，我们把**内排序分为：插入排序、交换排序、选择排序和归并排序。**

##### 排序用到的结构与函数

这里先提供一个用于排序用的顺序表结构，这个结构将用于接下来介绍的所有排序算法。

```c++
#define MAXSIZE 10
typedef struct
{
  // 用于存储待排序数组
  int r[MAXSIZE]; 
  // 用于记录顺序表的长度
  int length;
}SqList;
```

此外，由于排序最常用到的操作是数组两元素的交换，这里写成一个函数，如下所示：

```c++
// 交换L中数组r的下标为i和j的值
void swap(SqList *L, int i, int j){
  int temp = L->r[i];
  L->r[i] = L->r[j];
  L->r[j] = temp;
}
```

#### 冒泡排序

> **冒泡排序(Bubble sort)是一种交换排序。**它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，知道没有反序的记录为止。

首先介绍一个简单版本的冒泡排序算法的实现代码。

```c++
// 冒泡排序初级版
void BubbleSort0(SqList *L){
	int i, j;
	for (i = 0; i < L->length - 1; i++) {
		for (j = i + 1; j <= L->length - 1; j++){
			if (L->r[i] > L->r[j]){
				// 实现递增排序
				swap(L, i, j);
			}
		}
	}
}
```

这段代码不算是标准的冒泡排序算法，因为不满足“两两比较相邻记录”的冒泡排序思想，它更应该是最简单的交换排序。它的思路是让每一个关键字都和后面的每一个关键字比较，如果大或小则进行交换，这样关键字在一次循环后，第一个位置的关键字会变成最大值或者最小值。

这个最简单的实现算法效率是非常低的。

下面介绍正宗的冒泡排序算法实现。

```c++
// 正宗的冒泡排序算法实现代码
void BubbleSort(SqList *L){
	int i, j;
	for (i = 0; i < L->length; i++) {
		for (j = L->length - 2; j >= i; j--){
			// j是从后往前循环
			if (L->r[j] > L->r[j + 1]){
				// 实现递增排序
				swap(L, j, j + 1);
			}
		}
	}
}
```

这里改变的地方是在内循环中，`j`是从数组最后往前进行比较，并且是逐个往前进行相邻记录的比较，这样最大值或者最小值会在第一次循环过后，从后面浮现到第一个位置，如同气泡一样浮到上面。

这段实现代码其实还是可以进行优化的，例如待排序数组是`{2,1,3,4,5,6,7,8,9}`,需要进行递增排序，可以发现其实只需要交换前两个元素的位置即可完成，但是上述算法还是会在交换完这两者位置后继续进行循环，这样效率就不高了，所以可以在算法中增加一个标志，当有一次循环中没有进行数据交换，就证明数组已经是完成排序的，此时就可以退出算法，实现代码如下：

```c++
// 改进版冒泡算法
void BubbleSortOptimz(SqList *L){
	int i, j;
	bool flag = true;
	for (int i = 0; i < L->length && flag; i++){
		// 若 flag为false则退出循环
		flag = false;
		for (j = L->length - 2; j >= i; j--){
			// j是从后往前循环
			if (L->r[j] > L->r[j + 1]){
				// 实现递增排序
				swap(L, j, j + 1);
				// 如果有数据交换，则flag是true
				flag = true;
			}
		}
	}
}
```

冒泡排序算法的时间复杂度是$O(n^2)$。

完整的冒泡排序算法代码可以查看[BubbleSort](https://github.com/ccc013/DataStructe-Algorithms_Study/SortAlgorithms/BubbleSortTest.cpp)。

#### 简单选择排序

> 简单选择排序算法(Simple Selection Sort)就是通过$n-i$次关键字间的比较，从$n-i+1$个记录中选出关键字中最小的记录，并和第$i(1\le i \le n)$个记录进行交换。

下面是实现的代码：

```c++
// 简单选择排序算法
void SelectSort(SqList *L){
	int i, j, min;
	for (i = 0; i < L->length - 1; i++){
		// 将当前下标定义为最小值下标
		min = i;
		for (j = i + 1; j <= L->length - 1; j++){
			if (L->r[j] < L->r[min])
				min = j;
		}
		// 若min不等于i，说明找到最小值，进行交换
		if (min != i)
			swap(L, i, min);
	}
}
```

简单选择排序的最大特点就是交换移动数据次数相当少。分析其时间复杂度发现，无论最好最差的情况，比较次数都是一样的，都需要比较$\sum_{i=1}^{n-1} (n-i) = (n-1)+(n-2)+\cdots+2+1=\frac{n(n-1)}{2}$次。对于交换次数，最好的时候是交换0次，而最差的情况是$n-1$次。因此，总的时间复杂度是$O(n^2)$，虽然与冒泡排序一样的时间复杂度，但是其性能上还是略好于冒泡排序。

#### 直接插入排序

> 直接插入排序(Straight Insertion Sort)的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增加1的有序表。

实现代码如下：

```c++
// 直接插入排序
void InsertSort(SqList *L){
	int i, j,val;
	for (i = 1; i <= L->length - 1; i++){
		if (L->r[i] < L->r[i - 1]){
			// 将L->r[i]插入有序表中,使用val保存待插入的数组元素L->r[i]
			val = L->r[i];
			for (j = i - 1; L->r[j]>val; j--)
				// 记录后移
				L->r[j + 1] = L->r[j];	
			// 插入到正确位置
			L->r[j + 1] =val;
		}
	}
}
```

直接插入排序算法是需要有一个保存待插入数值的辅助空间。

在时间复杂度方面，最好的情况是待排序的表本身就是有序的，如{2,3,4,5,6}，比较次数则是$n-1$次，然后不需要进行移动，时间复杂度是$O(n)$。

最差的情况就是待排序表是逆序的情况，如{6,5,4,3,2},此时需要比较$\sum_{i=2}^{n} i = \frac{(n+2)(n-1)}{2}$次，而记录的移动次数也达到最大值$\sum_{i=2}^{n} (i+1) = \frac{(n+4)(n-1)}{2}$次。

如果排序记录是随机的，那么根据概率相同的原则，平均比较和移动次数约为$\frac{n^2}{4}$。因此，可以得出直接插入排序算法的时间复杂度是$O(n^2)$。同时也可以看出，直接插入排序算法会比冒泡排序和简单选择排序算法的性能要更好一些。

#### 希尔排序

上述三种排序算法的时间复杂度都是$O(n^2)$，而希尔排序是突破这个时间复杂度的第一批算法之一。

其实直接插入排序的效率在某些情况下是非常高效的，这些情况是指记录本来就很少或者待排序的表基本有序的情况，但是这两种情况都是特殊情况，在现实中比较少见。而希尔排序就是通过创造条件来改进直接插入排序的算法。

希尔排序的做法是**将原本有大量记录数的记录进行分组，分割成若干个序列**，这样每个子序列待排序的记录就比较少了，然后就可以对子序列分别进行直接插入排序，**当整个序列基本有序时，再对全体记录进行一次直接插入排序。**

这里的**基本有序是指小的关键字基本在前面，大的基本在后面，不大不小的在中间。**像{2,1,3,6,4,7,5,8,9}可以称为基本有序。

这里的关键就是如何进行分割，希尔排序采取的是**跳跃分割的策略：将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。**

实现的代码如下：

```c++
// 希尔排序
void ShellSort(SqList *L){
	int i, j,val;
	int increment = L->length;
	do{
		// 增量序列
		increment = increment / 3 + 1;
		for (i = increment; i <= L->length - 1; i++){
			if (L->r[i]<L->r[i - increment]){
				// 将L->r[i]插入有序表中,使用val保存待插入的数组元素L->r[i]
				val = L->r[i];
				for (j = i - increment; j >= 0 && L->r[j]>val; j -= increment)
					// 记录后移，查找插入位置
					L->r[j + increment] = L->r[j];
				L->r[j + increment] = val;
			}
		}
	} while (increment > 1);
}
```

上述代码中增量的选取是`increment = increment / 3 + 1`，实际上增量的选取是非常关键的，现在还没有人找到一种最好的增量序列，但是大量研究表明，当增量序列是$\delta [k] = 2^{t-k+1} - 1 (0\le k \le t \le \lfloor log_2(n+1)\rfloor)$时，可以获得不错的效率，其时间复杂度是$O(n^{\frac{3}{2}})$，要好于直接插入排序的$O(n^2)$。当然，这里需要注意的是**增量序列的最后一个增量值必须等于1才行**。此外，由于记录是跳跃式的移动，**希尔排序是不稳定的排序算法**。

#### 堆排序



