# [机器学习笔记]Note7--神经网络：学习

标签（空格分隔）： 机器学习

---
[TOC]

继续是[机器学习课程](https://www.coursera.org/learn/machine-learning)的笔记，这节课会继续介绍神经网络的内容，上一节主要是基本的介绍，以及模型表示，而本节会介绍代价函数，反向传播算法等。

### 神经网络代价函数
  首先是有如下一个神经网络，这里将首先介绍一些标记符号的意思。
  
* **L** 代表一个神经网络中的层数
* $S_l$ 代表第$l$层的处理单元(包括偏置单元)的个数
* $S_L$ 代表最后一层中处理单元的个数
* **K** 代表我们希望分类的类的个数，与$S_L$相等

  ![此处输入图片的描述][1]
  所以上图显示的神经网络是一个4层，输出结果也是4个结果，也就是**K**=4，$S_L=S_4$。
  
  在[逻辑回归归一化][2]中，我们的代价函数如下所示：
$$
J(\theta) = -\frac{1}{m} [\sum_{i=1}^my^{(i)}logh_\theta(x^{(i)})+(1-y^{(i)}log(1-h_\theta(x^{(i)}))] + \frac{\lambda}{2m} \sum_{j=1}^n \theta_j^2
$$
这里我们只有一个输出变量，也称为**标量(scalar)**，也就是一个因变量$y$.
但是在神经网络中，可以有很多输出变量，这里的$h_\theta(x)$是一个维度为**K**的向量，并且训练集中的因变量也是同样维度的一个向量，因此，得到的代价函数会比逻辑回归更加复杂一些，如下所示：
$$
J(\theta) = -\frac{1}{m} [\sum_{i=1}^m \sum_{k=1}^K y_k^{(i)}log(h_\theta(x^{(i)}))_k+(1-y_k^{(i)}log(1-(h_\theta(x^{(i)}))_k)] + \frac{\lambda}{2m} \sum_{l=1}^{L-1} \sum_{i=1}^{s_l} \sum_{j=1}^{s_l+1} (\theta_{ji}^{(l)})^2
$$
上述式子归一化那项中排除了每一层的$\theta_0$,同时最里层的循环j循环所有的行(由$s_l+1$层的激活单元数决定)，循环i则循环所有的列，由该层($s_l$层)的激活单元数所决定。

### 反向传播算法
 在上一节中介绍了正向传播方法来计算神经网络的输出结果，现在需要计算代价函数的偏导数$\frac{\partial}{\partial \theta_{ij}^{(l)}}J(\theta)$，需要采用一种反向传播算法，也就是首先计算最后一层的误差，然后再一层层反向求出各层的误差，直到倒数第二层。
 
 下面以一个开头给出的4层神经网络来说明反向传播算法。
 假设训练集只有一个实例$(x^{(1)},y^{(1)})$,使用一个四层的神经网络，其中，K=4，$S_L=4$，L=4。
 
 从最后一层的误差开始计算，误差$\delta$是激活单元的预测$a_k^{(4)}$与实际值$y_k$之间的误差，即$\delta^{(4)}=a^{(4)}-y$,这里是使用向量化表示，所以不需要使用下标k。
 
 接着利用这个误差值计算前一层，也就是第三层的误差：
 $$
 \delta^{(3)} =(\theta^{(3)})^T\delta^{(4)}.*g^{\prime}(z^{(3)})
 $$
其中$g^{\prime}(z^{(3)})$是S形函数的导数，$g^{\prime}(z^{(3)})=a^{(3)}.*(1-a^{(3)})$,而$(\theta^{(3)})^T\delta^{(4)}$是权重导致的误差的和。

下一步就是继续计算第二层的误差：
$$
 \delta^{(2)} =(\theta^{(2)})^T\delta^{(3)}.*g^{\prime}(z^{(2)})
$$
由于第一层是输入变量，不存在误差，我们有了所有的误差的表达式后，便可以计算代价函数的偏函数了，假设$\lambda=0$,即不做任何归一化处理时，有:
$$
\frac{\partial}{\partial \theta_{ij}^{(l)}}J(\theta)=a_j^{(l)}\delta_i^{(l+1)}
$$

如果考虑归一化处理，并且训练集是一个特征矩阵而非向量。在上述的特殊情况中，是需要计算每一层的误差单元来计算代价函数的偏导数。而在更为一般的情况中，同样需要计算每一层的误差单元，但是更需要为整个训练集计算误差单元，此时的误差单元就是一个矩阵。使用$\triangle_{ij}^{(l)}$来表示这个误差矩阵，第$l$层的第$i$个激活单元受到第$j$个参数影响而导致的误差。

算法如下所示：
![此处输入图片的描述][3]

即首先是用整向传播算法计算出每一层的激活单元，利用训练集的结果和神经网络预测的结果求出最后一层的误差，再利用该误差使用反向传播算法计算出直至第二层的所有误差。

求出了$\triangle_{ij}^{(l)}$之后，我们便可以计算代价函数的偏导数了，计算方法如下：
$$
D_{ij}^{(l)}=\frac{1}{m}\triangle_{ij}^{(l)}+\lambda \theta_{ij}^{(l)} \quad if\ j \neq 0 \\
D_{ij}^{(l)}=\frac{1}{m}\triangle_{ij}^{(l)} \qquad \qquad if\ j = 0
$$

### 梯度检验
  当对一个比较复杂的模型，如神经网络，使用梯度下降算法时，可能会存在一些不容易察觉的错误，意味着，虽然代价看上去在减小，但最终的结果可能并不是最优解。
  
  为了避免这样的问题，我们将采取一种叫做**梯度的数值检验(Numerical Gradient Checking)**方法。这种方法的思想是通过估计梯度值来检验我们计算的导数值是否真的是我们要求的。
  
  对梯度估计采用的方法是**在代价函数上沿着切线的方向选择两个非常近的点然后计算两个点的平均值用以估算梯度。**也就是对于某个特定的$\theta$,我们计算出在$\theta-\epsilon$处和$\theta+\epsilon$的代价值($\epsilon$是一个非常小的值，通常选取0.001)，然后求两个代价的平均，用以估算在$\theta$处的值，如下图所示：
  ![此处输入图片的描述][4]
  
  当$\theta$是一个向量时，我们则需要对偏导数进行检验，因为代价函数的偏导数检验只针对一个参数的改变进行检验，即如下所示，下面是一个只针对$\theta_1$进行检验的示例：
$$
\frac{\partial}{\partial \theta_1}=\frac{J(\theta_1+\epsilon,\theta_2,\theta_3,\ldots,\theta_n)-J(\theta_1-\epsilon,\theta_2,\theta_3,\ldots,\theta_n)}{2\epsilon}
$$
  
  然后需要通过反向传播算法计算出的偏导数进行检验，当两者比较接近就说明运行正确。
  
  这里有几点需要注意的：
  
* 在反向传播中计算出$J(\theta)$对$\theta$的导数D，并组成向量
* 用梯度检验法计算大概的梯度$gradApprox=\frac{J(\theta+\epsilon)-J(\theta-\epsilon)}{2\epsilon}$
* 判断上述两者是否相同或者接近
* 最重要的一点是，当需要使用神经网络学习的时候，必须停止使用梯度检验，否则会使得学习速度非常慢

### 随机初始化
  对于梯度下降算法和其他优化算法都是需要初始的参数。在之前逻辑回归中，对于$\theta$是初始化为0，这样做是对逻辑回归是可行的。但是对于神经网络却是不可行的，如果我们令所有的初始参数都为0，这意味着第二层的所有激活单元都会有相同的值。同理，如果将所有参数初始化为同一个非0的参数，结果也是一样的。
  
  因此，我们通常初始参数为$[-\epsilon,\epsilon]$的随机值。
  
### 小结
  这里小结下使用神经网络时的步骤：
  
**网络结构：**

第一件事要做的是选择网络结构，即选择多少层以及决定每层分别有多少个单元。

* 第一次的激活单元数就是训练集的特征数量
* 最后一层的激活单元数是训练集的结果的类的数量
* 如果隐藏层数大于1，确保每个隐藏层的单元个数相同，通常情况下隐藏层单元的个数越多越好

所以我们真正要决定的是隐藏层的层数以及其单元数。

**训练神经网络**

* 权重随机初始化
* 使用正向传播方法计算所有的$h_\theta(x)$
* 编写计算代价函数$J(\theta)$的代码
* 使用反向传播算法计算所有的偏导数
* 使用梯度数值检验方法检验这些偏导数
* 使用梯度下降算法或其他优化算法来最小化代价函数




  [1]: http://img.blog.csdn.net/20160629201909620
  [2]: http://blog.csdn.net/lc013/article/details/51694454
  [3]: http://img.blog.csdn.net/20160629212244172
  [4]: http://img.blog.csdn.net/20160701184819839