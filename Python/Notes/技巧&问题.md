# 技巧&amp;问题

<a name="qJvQD"></a>
# 1. Get an array back from an itertools.chain object
参考：<br />[Get an array back from an itertools.chain object](https://stackoverflow.com/questions/26853860/get-an-array-back-from-an-itertools-chain-object)

例子：

```python
list_of_numbers = [[1, 2], [3], []]
import itertools
chain = itertools.chain(*list_of_numbers)
```

解决方法：<br />
采用如下方法：

```python
list(chain)
```

但会在外层多嵌套一个列表，并且根据回答，可能效率不高。

利用 numpy 库

```python
>>> import numpy as np
>>> from itertools import chain
>>> list_of_numbers = [[1, 2], [3], []]
>>> np.fromiter(chain(*list_of_numbers), dtype=int)
array([1, 2, 3])
>>> list_of_numbers = [[1, 2]*1000, [3]*1000, []]*1000
>>> %timeit np.fromiter(chain(*list_of_numbers), dtype=int)
10 loops, best of 3: 103 ms per loop
>>> %timeit np.array(list(chain(*list_of_numbers)))
1 loops, best of 3: 199 ms per loop
```

<a name="s3L1P"></a>
# 2. flatten list
**碾平列表**，即当列表里面嵌套列表，如何将这些子列表给取出来，得到一个不包含子列表的列表，示例如下：

```python
list1 = [1, [2, [3,4]], 5]

=>new_list = [1, 2, 3, 4, 5]
```

**方法1：利用递归的思想**，代码如下：

```python
list1 = [1, [2, [3,4]], 5]
res = []

def fun(s):
    for i in s:
        if isinstance(i, list):
            fun(i)
        else:
            res.append(i)

fun(list1)
print(res)
```

接着是两种高级的写法：

**方法2：**

```python
flat = lambda L: sum(map(flat, L), []) if isinstance(L, list) else [L]

print(flat(list1))
```

**方法3：**

```python
a = [1, 2, [3, 4], [[5, 6], [7, 8]]]

flatten = lambda x: [y for l in x for y in flatten(l)] if type(x) is list else [x]

print(flatten(a)
```

两种方法都结合了多种技巧，非常简洁，但理解起来也很困难！

---

<a name="t0kLS"></a>
# 3. list 去重保持顺序

<a name="oMTHE"></a>
## 去重，但改变顺序

方法1

```
l1 = ['b','c','d','b','c','a','a']
l2 = list(set(l1))
print l2
```

方法2：

```
l1 = ['b','c','d','b','c','a','a']
l2 = {}.fromkeys(l1).keys()
print l2
```

<a name="M0x3U"></a>
## 去重，不改变顺序

```
l1 = ['b','c','d','b','c','a','a']
l2 = sorted(set(l1),key=l1.index)
print l2
```

---

<a name="WrQ2V"></a>
# 4. 字符串常量转为变量

来自：

- [Python进阶：如何将字符串常量转为变量？](https://mp.weixin.qq.com/s/4eWQmJ15QZabNViePCDmNw)

> 已知 list = ['A', 'B', 'C', 'D'] , 如何才能得到以 list 中元素命名的新列表 A = [], B = [], C = [], D = []呢?


第一种解法：

```
>>> list1 = ['A', 'B', 'C', 'D']
>>> for i in list1:
>>>     globals()[i] = []
>>> A
[]
```

**<br />这个方法通过**修改全局命名空间**，巧妙地“定义”出了新的变量。**`globals()` 方法取出来的是一个字典，字符串 ‘A’ 是其中一个键值（key），而这个键值恰恰是全局命名空间中的一个变量，这就实现了从常量到变量的转化。

在数据结构层面上，空列表 `[]` 作为一个值（value）跟它的字符串键值绑定在一起，而在运用层面上，它作为**变量内容而跟变量名绑定在一起**。

第二种解法：

```
>>> list1 = ['A', 'B', 'C', 'D']
>>> for i in list1:
>>>     exec(f"{i} = []")
>>> A
[]
```

用到了 `Python 3.6` 才引入的 `f-strings` 特性，事实上，在较低版本中，也是可以实现的，只需要保证 `exec()` 方法接收的参数是包含了变量 `i` 的字符串即可，例如这样写：

```
# 以下代码可替换上例的第 4 行
exec(i + " = []")
# 或者：
exec("{} = []".format(i))
# 或者：
exec(' '.join([i, '= []']))
```

这里的关键是 `exec()` 方法，它是内置的，用途是**执行储存在字符串或文件中的代码段**。

它的基础用法如下：

```
>>> exec('x = 1 + 2')
>>> x
3

# 执行代码段
>>> s = """
>>> x = 10
>>> y = 20
>>> sum = x + y
>>> print(sum)
>>> """
>>> exec(s)
30
```

注意：在 `Python3` 中，`exec()` 是个内置方法；而在 `Python2` 中，`exec` 是个语句（statement），另外有个 `execfile()` 方法，两者相合并，就成了 `Python3` 中的 `exec()` 方法。本文使用的是 `Python3`。

---


<a name="o9yNf"></a>
# 5. 当 list,dic作为默认参数的正确写法

参考：

- [python 当list,dic作为默认参数的正确写法](https://blog.csdn.net/emaste_r/article/details/47358843)

给出如下例子：

```
def extendList(val,list=[]):
    list.append(val)
    return list
 
list1 = extendList(10)
list2 = extendList(123,[])
list3 = extendList('a')
 
print list1
print list2
print list3
```

输出结果是：

```
[10, 'a']
[123]
[10, 'a']
```

原因是：

**原来当 list 等可变类型作为默认参数时，仅仅在定义函数的时候（也就是执行 def 语句）被计算一次，有且仅有这么一次**。

其它的时候无论调用几次函数，**如果没有传参进来，就会一直用这个默认参数了**。

正确的写法如下：

```
def foo(a, b=None):
    if b is None:
        b = []
    b.append(a)
    print b
 
foo(1)
foo(2)
```

总结：

1. 当 list、dic 等可变类型作为函数默认参数并且调用函数时没有传参的时候，要**注意 list、dic 并不会自己清空**。
1. **默认参数只在 def 语句被执行的时候计算一次**。
1. 如果想要的话，**把默认参数当成静态变量**（也就是全局变量）也是一种抖机灵的好思路呢。

---


