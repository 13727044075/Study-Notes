## 操作系统知识点

* **特权指令是作用于操作系统系统态的**，一般不直接提供给用户使用。

* 系统开机后，操作系统的程序会被自动加载到内存中的系统区，这段区域是RAM。

* 单处理机计算机系统中，**处理机操作和通道操作是并行的。**

* 操作系统在计算机系统中位于**硬件和用户软件**之间。

* 操作系统的主要功能有**控制和管理计算机系统软硬件资源**。

* 处于运行状态的操作系统程序应放在**主存中**。

* **通道是独立于中央处理器的，专门负责数据I/O传输工作的理单元。**从现代计算机系统的结构上看，各种外部设备均有相应的设备控制器，这些设备控制器再通过通道连接在计算机系统的公共系统总线上。

  通道对外部设备实行统一管理，它代替CPU对I/O操作进行控制，从而使CPU和外部设备可以并行工作。所以通道又称为I/O处理机。

  采用通道这种I/O结构的最大优点是，可以实现中央处理器和各种外部设备并行工作。

  采用通道之后，处理器和外部设备都能够访问主存储器。不过，当处理器和外部设备同时申请访问主存储器时，就要竞争存储周期 。由主存储器的控制经路处理这些竞争，并保证这些访问同步有序地进行。

  **有了通道，利用中央处理器和外部设备之间以及各外部设备之间的并行工作能力，操作系统就可以让多个程序同时执行，并在同一时刻让各个程序分别使用计算机系统的不同资源。**

  通道技术一般用于大型机系统和那些对I/O处理能力要求比较严格的系统中。一般低档次的微机中没有通道

* **缓冲技术是用在外部设备与其他硬件部件之间的一种数据暂存技术，它利用存储器件在外部设备中设置了数据的一个存储区域，称为缓冲区。缓冲技术一般有两种用途，一种是用在外部设备与外部设备之间的通信上的，还有一种是用在外部设备和处理器之间的。**

  **采用缓冲技术最根本的原因是，CPU处理数据速度与设备传输数据速度不相匹配，需要用缓冲区缓解其间的速度矛盾。**

  那么为什么不直接把数据送入用户工作区，而要设置缓冲区来暂存呢？如果把用户工作区直接作为缓冲区则有许多不便。首先，当一个用户从工作区向设备输出或从设备向工作区输入时，工作区被长期占用而使其他用户无法使用。其次，为了减少输入输出次数，以减轻对通道和输入输出设备的压力。第三，缓冲区信息可供多个用户共同使用以及反复使用，减少了不必要的信息传递工作，提高了效率，方便了对缓冲区的管理。

  为了提高设备利用率，通常使用单个缓冲区是不够的，可以设置双缓冲区、甚至多缓冲区。比如，在单缓冲区情况下，当外部设备向缓冲区输入数据装满之后 ，必须等待CPU将其取完，才能继续向其中输入数据。如果有两个缓冲区，在一个缓冲区等待CPU取用数据时，另一个可以继续接收数据，这样设备利用率可大为提高。

* 现代机器都是**GHz**，所以对于处理如1G大小的字符数组，需要的时间数量级是1秒。

* **系统调用的目的是请求系统服务**。

------
#### 进程

* 进程间共享通信的方式主要有：**管道、信号量、消息队列、共享内存、信号、套接口**


  常见进程间通信方式的比较：

  管道：速度慢，容量有限

  消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。

  信号量：不能传递复杂消息，只能用来同步

  共享内存区：**能够很容易控制容量，速度快，但要保持同步，**比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了一块内存的。

* 进程在运行中不断地改变其运行状态。通常，一个运行进程必须具有以下三种基本状态：就绪(Ready)状态、执行（Running）状态和阻塞(Blocked)状态。

* 进程在等待CPU时，就处于就绪状态。

* 可以改变进程优先级的命令是`renice`。

* **CPU的数据处理和I/O操作往往是并行处理的**。**并行**是指两个或者多个事件在**同一时刻发生**；而**并发**是指两个或多个事件在**同一时间间隔内发生**

* 在操作系统中，可以并行工作的基本单位是**进程。**

* 操作系统必须有一个进程，一个进程必须有一个线程;

* 线程必定从属于某个进程；

* 线程不能更改从属的进程；

* **强迫性中断由随机事件引起而非程序员事先安排, 硬件故障中断,程序性中断,外部中断及输入/输出中断是强迫性中断.**

* 分时系统的四个特点：

  1、多路性。允许一台主机上联接多台终端，系统按分时原则为每个用户服务；

  2、独立性。每个用户各占一个终端，独立操作，互不干扰；

  3、及时性。用户的请求能在很短的时间内获得响应；

  4、交互性。用户可通过终端与系统进行广泛的人机对话。

* 信号量当前值为-（m-1），当前为-4，表示有5个进程共享同一临界资源，但是临界资源只能由一个进程享用，因此等待的进程数为4，其实等待的进程数就是（m-1）。

* 两个合作进程，无法利用**高级语言的全局变量传递信息**。

* 降低进程优先级的合理时机是**进程的时间片用完**，而**提高优先级**的时机是**a)进程刚完成I/O，进入就绪列队；b)进程从就绪态转为运行态；c)进程长期处于就绪队列中。**

* **进程上下文实际上是进程执行活动全过程的静态描述。**

* 关于多进程和多线程编程，有：

  * 多进程之间的数据共享比多线程编程复杂，因为不同进程有不同的页表，对应着不同的物理地址空间，因此进程间通信需要使用IPC或者socket。而线程可以共享了进程的地址空间；
  * 多线程的创建、切换和销毁速度快于多进程，进程的创建需要操作系统为它分配内存，销毁时回收内存，而线程不需要；
  * 对于大量的计算，优先使用多线程，存在大量计算需求时，如需要并发计算，会频繁的切换进程/线程，而线程切换的成本小于进程；
  * 多线程没有内存隔离，单个线程奔溃会导致整个应用程序的退出，因为同一进程的不同线程共享地址空间，所以一个线程挂掉可能会导致整个进程挂掉。

* 同步信号量的初值一般设为0；

  互斥信号量的初值一般设为1；

* **生产者和消费者对缓冲区互斥访问是互斥关系，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后，消费者才能消费，他们也是同步关系**

* **sleep()是Thread类中的方法，而wait()则是Object类中的方法。** 

* sleep()方法导致了程序暂停，**但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，线程不会释放对象锁。 **

* **wait()方法会导致线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。** **注意是准备获取对象锁进入运行状态，而不是立即获得**

* 运行态：进程占用CPU，并在CPU上运行； 
  就绪态：进程已经具备运行条件，但是CPU还没有分配过来； 
  阻塞态：进程因等待某件事发生而暂时不能运行； 进程在一生中，都处于上述3中状态之一。

  **运行---》就绪： 时间片用完。** 
  **就绪---》运行：运行的进程的时间片用完，调度就转到就绪队列中选择合适的进程分配CPU** 
  **运行---》阻塞：发生了I/O请求或等待某件事的发生** 
  **阻塞---》就绪:进程所等待的事件发生，就进入就绪队列**

* P操作是阻塞作用

* V操作是唤醒作用

* 进程间可以共享的数据有以下几类，**进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。**

* 抢占式多任务处理中，进程被抢占时，需要保存的运行环境有：**所有cpu寄存器的内容、页表和程序计数器**。

* 程序和进程的区别有：

  * 程序是指令的有序集合，其本身没有任何运行的含义，是**一个静态的概念**。而进程是程序在处理机上的一次执行过程，它是一个动态的概念
  * 程序可以作为一种软件资料**长期存在**，而进程是有一定生命期的。**程序是永久的，进程是暂时的**。
  * **程序没有状态，而进程是有状态的，**进程状态分为五个基本状态，即**初始状态，就绪状态，执行状态，等待状态与终止状态**

* 进程A读取B进程中的某个变量（非共享内存），可行的方式有

  * 进程向消息队列写入一个包含变量内容的消息，B进程从队列中读出——消息队列的实现方式
  * 通过本地环路通信——本地socket通信方式
  * 如果A、B非亲属，那么A通过命名管道把这个变量的地址发给B进程——命名管道通信方式

* **进程的特性：结构性，动态性，独立性，并发性**

* **进程是资源分配的基本单位，线程是调度的基本单位**

* 进程退出时销毁的应该是这个进程独立拥有的一系列资源，**包括文件，网络，内存等等**，但是**共享内存是进程间通信方式的一种，不仅仅是该进程所独有的，若共享内存销毁后可能会影响其他进程**

* **自旋锁（spinlock）是一种保护临界区最常见的技术**。在同一时刻只能有一个进程获得自旋锁，其他企图获得自旋锁的任何进程将一直进行尝试（即自旋，不断地测试变量），除此以外不能做任何事情。**因此没有获得自旋锁的进程在获取锁之前处于忙等**

* 系统开销比率等于**切换进程总时间 / 进程总共运行时间**


##### 1. 调度算法

* 短作业优先又称为“短进程优先”SPN(Shortest Process Next)；这是对FCFS算法的改进，其目标是减少平均周转时间。

    定义：
  对预计执行时间短的作业（进程）优先分派处理机。通常后来的短作业不抢先正在执行的作业。
  SJF的特点：
  (1) 优点：
  比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间；
  提高系统的吞吐量；
  (2) 缺点：
  对长作业非常不利，可能长时间得不到执行；
  未能依据作业的紧迫程度来划分执行的优先级；
  难以准确估计作业（进程）的执行时间，从而影响调度性能。

* 考虑到**紧迫型作业**进入系统后能得到优先处理，引入了**最高优先级优先调度算法**。

* 对于分时操作系统， CPU 进行进程的调度经常采用的算法是**时间片轮转**。

* 分时系统中确定时间片大小需要考虑的因素有：**就绪队列中进程的数目、系统的处理能力和系统对响应时间的要求**。

* 满足短任务优先且不会发生饥饿现象的调度算法是**高响应比优先**，这是由于**响应比等于等待时间加上服务时间再除以服务时间**，所以等待时间相同时，短作业的响应比更大，能优先获得时间片，另一方面，当服务时间相同时，等待时间越长，响应比越大，所以同时照顾了长作业

* 常见的调度算法：

  1.**先来先服务调度算法（FCFS）**:就是按照各个作业进入系统的自然次序来调度作业。这种调度算法的优点是实现简单，公平。其缺点是没有考虑到系统中各种资源的综合使用情况，往往使短作业的用户不满意，因为短作业等待处理的时间可能比实际运行时间长得多。 因此选A；

  2.**短作业优先调度算法** **(SPF):** 就是优先调度并处理短作业，所谓短是指作业的运行时间短。而在作业未投入运行时，并不能知道它实际的运行时间的长短，因此需要用户在提交作业时同时提交作业运行时间的估计值。  

  3.**最高响应比优先算法(HRN)：**FCFS可能造成短作业用户不满，SPF可能使得长作业用户不满，于是提出HRN，选择响应比最高的作业运行。响应比=1+作业等待时间/作业处理时间。 因此选C；

  4.**基于优先数调度算法(HPF)：**每一个作业规定一个表示该作业优先级别的整数，当需要将新的作业由输入井调入内存处理时，优先选择优先数最高的作业。

* 进程调度时，不可能发生的进程状态变化过程是**就绪挂起->阻塞挂起**。

##### 2. 线程

* **线程通常被定义为一个进程中代码的不同执行路线。**从实现方式上划分，线程有两种类型：**“用户级线程”和“内核级线程”。** 

* **用户线程指不需要内核支持而在用户程序中实现的线程**，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。这种线程甚至在象 DOS 这样的操作系统中也可实现，但线程的调度需要用户程序完成，这有些类似 Windows 3.x 的协作式多任务。

* **内核级线程需要内核的参与，由内核完成线程的调度。其依赖于操作系统核心**，由内核的内部需求进行创建和撤销，这两种模型各有其好处和缺点。

* **用户线程不需要额外的内核开支**，并且用户态线程的实现方式可以被定制或修改以适应特殊应用的要求，但是当一个线程因 I/O 而处于等待状态时，整个进程就会被调度程序切换为等待状态敏感词线程得不到运行的机会；而**内核线程则没有各个限制，有利于发挥多处理器的并发优势，但却占用了更多的系统开支**。 Windows NT和OS/2支持内核线程。Linux 支持内核级的多线程

* 线程共享的内容包括：

  1. 进程代码段
  2. 进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)
  3. 进程打开的文件描述符、
  4. 信号的处理器、
  5. 进程的当前目录和
  6. 进程用户ID与进程组ID

* 线程独有的内容包括：

  1. 线程ID
  2. 寄存器组的值
  3. 线程的堆栈
  4. 错误返回码
  5. 线程的信号屏蔽码

* ​

  ​

------
#### I/O输入输出

* 采用I/O通道控制方式后，I/O操作过程为：**当CPU在执行主程序时遇到I/O请求，CPU启动在指定通道上选址的设备**，一旦启动成功，通道开始控制设备进行操作，这时CPU就可以执行其他任务并与通道并行工作，直到I/O操作完成。**当通道发出I/O操作结束中断时，CPU才响应并停止当前工作，转而处理I/O操作结束事件**。因此，I/O通道控制方式**需要**CPU干预。

* **通道指令是用来执行I/O操作的指令，而一般指令是大众CPU指令。**通道是一种特殊的处理机，具有执行I/O指令集。

* **共享设备在同一时刻只能有一个作业调用。**

* 一次I/O请求对应一个I/O请求包

* 每次I/O请求都对应一个I/O请求包

* 每次I/O操作都会有对应I/O请求包


* **字节多路通道**和**数组多路通道**都是多路通道，在一段时间内均能交替执行多个设备的通道程序，使这些设备同时工作。**数组选择通道** 在一段时间内只允许执行一个设备的通道程序，只有当这个设备的通道程序全部执行完毕后，才能执行其他设备的通道程序。

* SPOOLing （即外部设备联机并行操作），即Simultaneous Peripheral Operation On-Line的缩写，它是关于**慢速字符设备如何与计算机主机交换信息**的一种技术，通常称为**“ 假脱机技术”**。

SPOOLing 技术特点：

  1. **提高了I/O速度**.从对低速I/O设备进行的I/O操作变为对输入井或输出井的操作,如同脱机操作一样,提高了I/O速度,缓和了CPU与低速I/O设备速度不匹配的矛盾.
  2. **设备并没有分配给任何进程**.在输入井或输出井中,分配给进程的是一存储区和建立一张I/O请求表.
  3. **实现了虚拟设备功能**.多个进程同时使用一独享设备,而对每一进程而言,都认为自己独占这一设备,不过,该设备是逻辑上的设备.


------
#### 存储管理

* 在请求分页系统中，页面分配策略与页面置换策略不能组合使用的是**固定分配，全局置换**，因为固定分配时页面数不变，不可能出现全局置换。常见的3种策略有：

  * 可变分配，全局置换；
  * 可变分配，局部置换；
  * 固定分配，局部置换；

* 内存管理中的LRU：全称是：Least Recently Used（最近最久未使用）置换算法，所以这个算法涉及到了**虚拟内存的分配和物理内存的释放。**

* **在FAT32文件系统中，磁盘空间的分配单位是簇**

* 把逻辑地址转变为内存的物理地址的过程称作**重定位或地址映射**。

* UNIX系统代码段和数据段分开的目的有：

  1）防止程序指令被修改，设置代码段权限为只读，设置数据段权限为可读写  

  2）代码段和数据段分开有利于提高程序的局部性，现代CPU缓存一般设计为数据缓存和指令缓存分离，指令和数据分开存放可以提高CPU缓存命中率。

  3）共享指令，当系统运行多个程序的副本时，它们指令时一样的，因此内存只需保存一份程序的指令代码。每个副本进程的数据区是进程私有，可以节省内存。

* 在请求分页系统中，每当所要访问的页面不在内存时，便产生一个缺页中断，请求操作系统将所缺的页调入内存。此时应将缺页的进程阻塞（调页完成唤醒)，如果内存中有空闲块，则分配一个块，将要调入的页装入该块，并修改页表中相应页表项，**若此时内存中没有空闲块，则要淘汰某页**（若**被淘汰页在内存期间被修改过，则要将其写回外存**)

* 一个作业需要占用**较大连续内存**的存储管理是**页式存储管理、段式存储管理和段页式存储管理**。

* **硬盘的存取访问时间分为三个部分：** **寻道时间Ts，旋转延迟时间Tr和传送时间Tt**

* **虚拟存储只能基于非连续分配技术**。

* 周转时间：从一个批处理作业提交时刻开始直到该作业完成时刻为止的统计的平均时间

  响应时间：作业等待时间+作业计算时间

  运行时间：作业计算时间

  等待调度时间：作业从后备作业到被调度程序选中的时间

* 抖动就是指当内存中已无空闲空间而又发生缺页中断时，需要从内存中调出一页程序或数据送磁盘的对换区中，如果算法不适当，刚被换出的页很快被访问，需重新调入，因此需再选一页调出，而此时被换出的页很快又要被访问，因而又需将它调入，如此频繁更换页面，以致花费大量的时间，我们称这种现象为"抖动";**所以在请求分页的时候如果处理不当则会发生抖动。**

* **物理地址=内存块号\*块长+页内地址  ；块的大小与页大小一致；**

* 请求分页系统中，页表中的访问位是供**页面置换**参考的。

* 在存储管理中，采用覆盖与交换技术的目的是**减少程序占用的主存空间**。

* 虚存管理和实存管理的主要区别是**实存要求程序全部装入内存才开始运行，虚存允许程序在执行的过程中逐步装入。**

* 链接存储结构是在计算机中用一组任意的存储单元存储线性表的数据元素。

  链式存储结构特点：
  1、**比顺序存储结构的存储密度小** (每个节点都由数据域和指针域组成，所以相同空间内假设全存满的话顺序比链式存储更多)。
  2、**逻辑上相邻的节点物理上不必相邻**。
  3、**插入、删除灵活** (不必移动节点，只要改变节点中的指针)。
  4、**查找结点时链式存储要比顺序存储慢。**
  5、**每个结点是由数据域和指针域组成**

* 换页错误又称缺页错误，当一个程序试图访问没有映射到物理内存的地方时，就会出现缺页错误， 这时操作系统就要去虚拟内存中加载这块内存页。

  **减少换页错误的方法，即降低缺页中断率**：

  1. **内存页框数。**增加作业分得的内存块数。
  2. **页面大小。**页面划分越大，中断率越低。
  3. **替换算法的优劣**影响缺页中断次数
  4. **程序局部性**。程序局部性好可减少缺页中断

* **相联存储器，** **它是一种不根据地址而是根据存储内容来进行存取的存储器,可以实现快速地查找块表**


------
#### 死锁

* 所谓死锁： **是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象**，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

* 在使用锁保证现场安全时可能会出现 活跃度 失败的情况主要包括 **饥饿、丢失信号、和活锁、死锁** 等。【多线程除了死锁之外遇到最多的就是活跃度问题了】

  **饥饿** ：**指线程需要访问的资源 被永久拒绝 ，以至于不能再继续进行**。解决饥饿问题需要平衡线程对资源的竞争，如线程的优先级、任务的权重、执行的周期等。

  **活锁** ：**指线程虽然没有被阻塞，但由于某种条件不满足，一直尝试重试却始终失败。**解决活锁问题需要对 重试机制 引入一些随机性。例如如果检测到冲突，那么就暂停随机的一定时间进行重试，这会大大减少碰撞的可能性。

* 银行家算法应该是：

  **系统处于安全状态时，一定不会发生死锁；系统处于不安全状态时，不一定会发生死锁；**

* 产生死锁的四个必要条件： 
  （1） **互斥条件**：一个资源每次只能被一个进程使用。 
  （2） **请求与保持条件**：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 
  （3） **不剥夺条件**:进程已获得的资源，在使用完之前，不能强行剥夺。 
  （4） **循环等待条件**:若干进程之间形成一种头尾相接的循环等待资源关系。

* **m个进程，每个进程需要n台机器**，（n-1,n-1,n-1……n-1）先给m个进程依次分配 n-1台机器，之后这m台机器都去抢夺最后一台机器，进入死锁状态，则总的机器资源数目为：**(n-1)*m+1**


------

#### 文件管理

* 顺序文件是**指按记录进入文件的先后顺序存放、其逻辑顺序和物理顺序一致的文件**。一切存储在顺序存取存储器(如磁带)上的文件，都只能是顺序文件。

* 对顺序文件，插入新纪录只能加在文件末尾；存取第i个记录，必须从头开始搜索；如要更新文件中的记录，必须将整个文件复制。

* **文件系统中的最小存储单元是逻辑块，也就是Block**；

* block越大，inode越少，适合存储大文件的文件系统；block越小，inode越多，适合存储文件多而小的文件系统。

* 要格式化档案系统为Ext3，亦可以使用命令mkfs.ext3,block块可以用mkfs.ext3 -b来制定快的大小，每个block块最多可存放一个文件;

* block存放文件的数据，每个block最多存放一个文件，而当一个block存放不下的情况下，会占用下一个block。

* 文件存储空间的管理：**1、空闲表法和空闲链表法；2、位示图法；3.成组链接法**

* 多关键字文件的特点是，**在对文件进行检索操作时，不仅仅对主关键词进行简单询问，还经常需要对次关键字进行其他类型的询问检索**。常见的有**多重表文件、倒排文件**

  ​

  ​