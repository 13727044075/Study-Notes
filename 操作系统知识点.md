## 操作系统知识点

* **特权指令是作用于操作系统系统态的**，一般不直接提供给用户使用。
* 系统开机后，操作系统的程序会被自动加载到内存中的系统区，这段区域是RAM。
* 单处理机计算机系统中，**处理机操作和通道操作是并行的。**
* 操作系统在计算机系统中位于**硬件和用户软件**之间。
* 操作系统的主要功能有**控制和管理计算机系统软硬件资源**。

------
#### 进程

* 进程间共享通信的方式主要有：**管道、信号量、消息队列、共享内存、信号、套接口**

* 进程在运行中不断地改变其运行状态。通常，一个运行进程必须具有以下三种基本状态：就绪(Ready)状态、执行（Running）状态和阻塞(Blocked)状态。

* 进程在等待CPU时，就处于就绪状态。

* 可以改变进程优先级的命令是`renice`。

* **CPU的数据处理和I/O操作往往是并行处理的。**并行是指两个或者多个事件在**同一时刻发生**；而并发是指两个或多个事件在**同一时间间隔内**发生

* 在操作系统中，可以并行工作的基本单位是**进程。**

* 操作系统必须有一个进程，一个进程必须有一个线程;

* 线程必定从属于某个进程；

* 线程不能更改从属的进程；

* **强迫性中断由随机事件引起而非程序员事先安排, 硬件故障中断,程序性中断,外部中断及输入/输出中断是强迫性中断.**

* 分时系统的四个特点：

  1、多路性。允许一台主机上联接多台终端，系统按分时原则为每个用户服务；

  2、独立性。每个用户各占一个终端，独立操作，互不干扰；

  3、及时性。用户的请求能在很短的时间内获得响应；

  4、交互性。用户可通过终端与系统进行广泛的人机对话。

* 信号量当前值为-（m-1），当前为-4，表示有5个进程共享同一临界资源，但是临界资源只能由一个进程享用，因此等待的进程数为4，其实等待的进程数就是（m-1）。

* 两个合作进程，无法利用**高级语言的全局变量传递信息**。

* 降低进程优先级的合理时机是**进程的时间片用完**，而**提高优先级**的时机是**a)进程刚完成I/O，进入就绪列队；b)进程从就绪态转为运行态；c)进程长期处于就绪队列中。**

* **进程上下文实际上是进程执行活动全过程的静态描述。**

* 关于多进程和多线程编程，有：

  * 多进程之间的数据共享比多线程编程复杂，因为不同进程有不同的页表，对应着不同的物理地址空间，因此进程间通信需要使用IPC或者socket。而线程可以共享了进程的地址空间；
  * 多线程的创建、切换和销毁速度快于多进程，进程的创建需要操作系统为它分配内存，销毁时回收内存，而线程不需要；
  * 对于大量的计算，优先使用多线程，存在大量计算需求时，如需要并发计算，会频繁的切换进程/线程，而线程切换的成本小于进程；
  * 多线程没有内存隔离，单个线程奔溃会导致整个应用程序的退出，因为同一进程的不同线程共享地址空间，所以一个线程挂掉可能会导致整个进程挂掉。

* 同步信号量的初值一般设为0；

  互斥信号量的初值一般设为1；

* **生产者和消费者对缓冲区互斥访问是互斥关系，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后，消费者才能消费，他们也是同步关系**

* **sleep()是Thread类中的方法，而wait()则是Object类中的方法。** 

* *sleep()方法导致了程序暂停，**但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，线程不会释放对象锁。 **

* **wait()方法会导致线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。** **注意是准备获取对象锁进入运行状态，而不是立即获得**

* 运行态：进程占用CPU，并在CPU上运行； 
  就绪态：进程已经具备运行条件，但是CPU还没有分配过来； 
  阻塞态：进程因等待某件事发生而暂时不能运行； 进程在一生中，都处于上述3中状态之一。运行---》就绪： 时间片用完。 
  **就绪---》运行：运行的进程的时间片用完，调度就转到就绪队列中选择合适的进程分配CPU** 
  **运行---》阻塞：发生了I/O请求或等待某件事的发生** 
  **阻塞---》就绪:进程所等待的事件发生，就进入就绪队列**

* P操作是阻塞作用

* V操作是唤醒作用

  ​



##### 1. 调度算法

* 短作业优先又称为“短进程优先”SPN(Shortest Process Next)；这是对FCFS算法的改进，其目标是减少平均周转时间。

    定义：
  对预计执行时间短的作业（进程）优先分派处理机。通常后来的短作业不抢先正在执行的作业。
  SJF的特点：
  (1) 优点：
  比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间；
  提高系统的吞吐量；
  (2) 缺点：
  对长作业非常不利，可能长时间得不到执行；
  未能依据作业的紧迫程度来划分执行的优先级；
  难以准确估计作业（进程）的执行时间，从而影响调度性能。

* 考虑到**紧迫型作业**进入系统后能得到优先处理，引入了**最高优先级优先调度算法**。

* 对于分时操作系统， CPU 进行进程的调度经常采用的算法是**时间片轮转**。

* 满足短任务优先且不会发生饥饿现象的调度算法是**高响应比优先**，这是由于**响应比等于等待时间加上服务时间再除以服务时间**，所以等待时间相同时，短作业的响应比更大，能优先获得时间片，另一方面，当服务时间相同时，等待时间越长，响应比越大，所以同时照顾了长作业

* 常见的调度算法：

  1.**先来先服务调度算法（FCFS）**:就是按照各个作业进入系统的自然次序来调度作业。这种调度算法的优点是实现简单，公平。其缺点是没有考虑到系统中各种资源的综合使用情况，往往使短作业的用户不满意，因为短作业等待处理的时间可能比实际运行时间长得多。 因此选A；

  2.**短作业优先调度算法** **(SPF):** 就是优先调度并处理短作业，所谓短是指作业的运行时间短。而在作业未投入运行时，并不能知道它实际的运行时间的长短，因此需要用户在提交作业时同时提交作业运行时间的估计值。  

  3.**最高响应比优先算法(HRN)：**FCFS可能造成短作业用户不满，SPF可能使得长作业用户不满，于是提出HRN，选择响应比最高的作业运行。响应比=1+作业等待时间/作业处理时间。 因此选C；

  4. **基于优先数调度算法(HPF)：**每一个作业规定一个表示该作业优先级别的整数，当需要将新的作业由输入井调入内存处理时，优先选择优先数最高的作业。

##### 2. 线程

* **线程通常被定义为一个进程中代码的不同执行路线。**从实现方式上划分，线程有两种类型：**“用户级线程”和“内核级线程”。** 

* **用户线程指不需要内核支持而在用户程序中实现的线程**，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。这种线程甚至在象 DOS 这样的操作系统中也可实现，但线程的调度需要用户程序完成，这有些类似 Windows 3.x 的协作式多任务。

* **内核级线程需要内核的参与，由内核完成线程的调度。其依赖于操作系统核心**，由内核的内部需求进行创建和撤销，这两种模型各有其好处和缺点。

* **用户线程不需要额外的内核开支**，并且用户态线程的实现方式可以被定制或修改以适应特殊应用的要求，但是当一个线程因 I/O 而处于等待状态时，整个进程就会被调度程序切换为等待状态敏感词线程得不到运行的机会；而**内核线程则没有各个限制，有利于发挥多处理器的并发优势，但却占用了更多的系统开支**。 Windows NT和OS/2支持内核线程。Linux 支持内核级的多线程

  ​

------
#### I/O输入输出

* 采用I/O通道控制方式后，I/O操作过程为：**当CPU在执行主程序时遇到I/O请求，CPU启动在指定通道上选址的设备**，一旦启动成功，通道开始控制设备进行操作，这时CPU就可以执行其他任务并与通道并行工作，直到I/O操作完成。**当通道发出I/O操作结束中断时，CPU才响应并停止当前工作，转而处理I/O操作结束事件**。因此，I/O通道控制方式**需要**CPU干预。

* **通道指令是用来执行I/O操作的指令，而一般指令是大众CPU指令。**通道是一种特殊的处理机，具有执行I/O指令集。

* **共享设备在同一时刻只能有一个作业调用。**

* 一次I/O请求对应一个I/O请求包

* 每次I/O请求都对应一个I/O请求包

* 每次I/O操作都会有对应I/O请求包


* ​

  ​

------
#### 存储管理

* 在请求分页系统中，页面分配策略与页面置换策略不能组合使用的是**固定分配，全局置换**，因为固定分配时页面数不变，不可能出现全局置换。常见的3种策略有：

  * 可变分配，全局置换；
  * 可变分配，局部置换；
  * 固定分配，局部置换；

* 内存管理中的LRU：全称是：Least Recently Used（最近最久未使用）置换算法，所以这个算法涉及到了**虚拟内存的分配和物理内存的释放。**

* **在FAT32文件系统中，磁盘空间的分配单位是簇**

* 把逻辑地址转变为内存的物理地址的过程称作**重定位或地址映射**。

* UNIX系统代码段和数据段分开的目的有：

  1）防止程序指令被修改，设置代码段权限为只读，设置数据段权限为可读写  

  2）代码段和数据段分开有利于提高程序的局部性，现代CPU缓存一般设计为数据缓存和指令缓存分离，指令和数据分开存放可以提高CPU缓存命中率。

  3）共享指令，当系统运行多个程序的副本时，它们指令时一样的，因此内存只需保存一份程序的指令代码。每个副本进程的数据区是进程私有，可以节省内存。

* 在请求分页系统中，每当所要访问的页面不在内存时，便产生一个缺页中断，请求操作系统将所缺的页调入内存。此时应将缺页的进程阻塞（调页完成唤醒)，如果内存中有空闲块，则分配一个块，将要调入的页装入该块，并修改页表中相应页表项，**若此时内存中没有空闲块，则要淘汰某页**（若**被淘汰页在内存期间被修改过，则要将其写回外存**)

* 一个作业需要占用**较大连续内存**的存储管理是**页式存储管理、段式存储管理和段页式存储管理**。

* **硬盘的存取访问时间分为三个部分：** **寻道时间Ts，旋转延迟时间Tr和传送时间Tt**

* **虚拟存储只能基于非连续分配技术**。

  ​


------
#### 死锁

* 所谓死锁： **是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象**，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

* 在使用锁保证现场安全时可能会出现 活跃度 失败的情况主要包括 **饥饿、丢失信号、和活锁、死锁** 等。【多线程除了死锁之外遇到最多的就是活跃度问题了】

  **饥饿** ：**指线程需要访问的资源 被永久拒绝 ，以至于不能再继续进行**。解决饥饿问题需要平衡线程对资源的竞争，如线程的优先级、任务的权重、执行的周期等。

  **活锁** ：**指线程虽然没有被阻塞，但由于某种条件不满足，一直尝试重试却始终失败。**解决活锁问题需要对 重试机制 引入一些随机性。例如如果检测到冲突，那么就暂停随机的一定时间进行重试，这会大大减少碰撞的可能性。

------

#### 文件管理

* 顺序文件是**指按记录进入文件的先后顺序存放、其逻辑顺序和物理顺序一致的文件**。一切存储在顺序存取存储器(如磁带)上的文件，都只能是顺序文件。
* 对顺序文件，插入新纪录只能加在文件末尾；存取第i个记录，必须从头开始搜索；如要更新文件中的记录，必须将整个文件复制。
* ​