
阅读《图解HTTP》的学习笔记。

参考文章如下：

- [HTTP 简介（菜鸟教程）](http://www.runoob.com/http/http-intro.html)
- [关于HTTP协议，一篇就够了](https://www.cnblogs.com/ranyonsue/p/5984001.html)
- [HTTP 方法：GET 对比 POST](http://www.w3school.com.cn/tags/html_ref_httpmethods.asp)

学习笔记分为两部分，第一部分主要介绍 HTTP 的基本知识，包括其优缺点、它的报文组成、可用方法、工作原理，还有就是状态码，报文首部的组成。而第二部分会介绍有关 HTTP 的安全问题，包括加密、认证方式等，还有介绍 Web 应用以及相关实现的技术。

---

## 1. HTTP 简介

HTTP（Hyper Text Transfer Protocol），也就是超文本传输协议，其设计的目的就是保证客户端和服务器之间的通信，其工作方式就是客户端和服务器之间的请求-响应协议。它是一个基于 TCP/IP 通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）

HTTP/1.0 版本诞生于 1996 年 5 月份，但随后 1.1 版本在 1997 年 1月份公布，是目前最主流的 HTTP 协议版本，而在 2015 年则公布了 HTTP/2.0 版本。

### 特点

HTTP 协议具有以下几个特点：

- **简单快速**：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。
- **灵活**：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。
- **HTTP是无连接**：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
- **HTTP是媒体独立的**：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过 HTTP 发送。客户端以及服务器指定使用适合的 MIME-type 内容类型。
- **HTTP是无状态**：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。后续引入 Cookie 技术解决这个问题。
- 使用**统一资源标识符（Uniform Resource Identifiers, URI）**来传输数据和建立连接。
- 支持 B/S 和 C/S 模式，即浏览器/服务器和客户端/服务器模式


### 缺点

- 通信使用明文（不加密），内容可能会被窃听
- 不验证通信方的身份，因此可能遭遇伪装
     - 有可能遭遇伪装的 Web 服务器
     - 有可能遭遇已伪装的客户端
     - 无法确定正在通信的对方是否具备访问权限
     - 无法判定请求是来自何方、出自谁手
     - 即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击(Denial of Service，拒绝服务攻击)
- 无法证明报文的完整性，所以有可能已遭篡改
     - 请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击被称为中间人攻击（Man-in-the-Middle attack, MITM）


### 方法

根据HTTP标准，HTTP请求可以使用多种请求方法。

HTTP 1.0 定义了三种请求方法： GET, POST 和 HEAD方法。

HTTP 1.1 新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。


序号 | 方法 | 描述
---|--- | ---
1 | GET | 请求指定的页面信息，并返回实体主体。
2 | HEAD | 类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头
3 | POST | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。
4 | PUT | 从客户端向服务器传送的数据取代指定的文档的内容。
5 | DELETE | 请求服务器删除指定的页面。
6 | CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。
7 | OPTIONS | 允许客户端查看服务器的性能。
8 | TRACE | 回显服务器收到的请求，主要用于测试或诊断。

#### GET 和 POST 的区别

GET 和 POST 的区别如下表所示：

项目 | GET | POST
---|--- | ---
后退按钮/刷新 | 无害 | 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。
书签 | 可收藏为书签 | 不能收藏为书签
缓存 |  能被缓存 | 不能缓存
编码类型 | application/x-www-form-urlencoded | application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。
历史 | 参数保留在浏览器历史中。 | 参数不会保存在浏览器历史中。
对数据长度的限制 | 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 | 无限制
对数据类型的限制 |只允许 ASCII 字符。 | 没有限制。也允许二进制数据。
安全性 | 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！ | POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。
可见性 | 数据在 URL 中对所有人都是可见的。 | 数据不会显示在 URL 中

### URI 和 URL

HTTP 使用统一资源标识符（Uniform Resource Identifiers,URI）来传输数据和建立连接。RFC 2396 分别对这三个单词进行了如下定义：

- Uniform：规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。另外，加入新增的协议方案（如 http: 或 ftp:）也更容易
- Resource；资源的定义是“可标识的任何东西”。不仅是文档文件，图像或服务（例如当天的天气预报）等能够区别于其他类型的，全都可作为资源。另外，资源不仅可以是单一的，也可以说是多数的集合体。
- Identifier：表示可标识的对象。也成为标识符。

综上所述，URI 就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。比如采用 HTTP 协议时，协议方案就是 http。除此之外，还有 ftp、mailto、telnet、file 等。标注的 URI 协议方案有30种左右。


#### URL 简介

URL 是一种特殊类型的 URI，包含了用于查找某个资源的足够的信息。它的全称是 Uniform Resource ocator,中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个 URL 为例，介绍下普通 URL 的各部分组成：

http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name

从上面的 URL 可以看出，一个完整的URL包括以下几部分：

1.协议部分：该 URL 的协议部分为 “http：”，这代表网页使用的是 HTTP 协议。在 Internet 中可以使用多种协议，如 HTTP，FTP 等等。本例中使用的是 HTTP 协议。在 "HTTP" 后面的“//”为分隔符；

2.域名部分：该 URL 的域名部分为“www.aspxfans.com”。一个 URL 中，也可以使用 **IP 地址作为域名使用**；

3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。**端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口**；

4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”；

5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名；

6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分；

7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。

（原文：http://blog.csdn.net/ergouge/article/details/8185219 ）

#### URL 和 URI 的区别

**URI，是 uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。**

Web 上可用的每种资源如 HTML 文档、图像、视频片段、程序等都是一个来 URI 来定位的 URI 一般由三部组成：

1. 访问资源的命名机制
2. 存放资源的主机名
3. 资源自身的名称，由路径表示，着重强调于资源。

**URL是uniform resource locator，统一资源定位器，它是一种具体的  URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。**

URL 是 Internet 上用来描述信息资源的字符串，主要用在各种 WWW 客户程序和服务器程序上，特别是著名的 Mosaic。

采用 URL 可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL 一般由三部组成：
1. 协议(或称为服务方式)
2. 存有该资源的主机IP地址(有时也包括端口号)
3. 主机资源的具体地址。如目录和文件名等

**URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如 mailto:java-net@java.sun.com。**

URI 是以一种抽象的，高层次概念定义统一资源标识，而 URL 和 URN 则是**具体的资源标识的方式**。URL 和 URN 都是一种 URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。

在 Java 的 URI 中，一个 URI 实例可以代表绝对的，也可以是相对的，只要它符合 URI 的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。

在 Java 类库中，URI 类不包含任何访问资源的方法，它唯一的作用就是解析。相反的是，URL 类可以打开一个到达资源的流。

### 持久连接

HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。在当时都是容量很小的文本传输的通信情况看，这个做法并没有什么问题。但是随着 HTTP 的普及，文档中包含大量图片的情况多了起来，当文档包含大量图片的时候，比如使用浏览器浏览一个包含多张图片的 HTML 页面的时候，会发生多次请求，但每次请求都会造成无谓的 TCP 连接和断开，增加了通信量的开销。

为解决上述问题，在 HTTP/1.0 版本中提出了持久连接（HTTP Persistent Connections, 也称为 HTTP keep-alive 或 HTTP connection reuse）的方法，**其特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。**

持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器的负载。另外减小开销的那部分时间，使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了。

### 管线化

持久连接使得多数请求得以管线化（pipelinling）方式发送成为可能。从前发送请求必须等待并收到响应后，才能发送下一个请求。但管线化技术出现后，可以做到**同时并行发送多个请求**，不需要一个一个等待响应。

管线化技术比持久连接还要快，并且请求数量越多，时间差就越明显。

### 工作原理

HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客户端。HTTP 协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。

以下是 HTTP 请求/响应的步骤：

**1、客户端连接到 Web 服务器**
一个 HTTP 客户端，通常是浏览器，与 Web 服务器的 HTTP 端口（默认为 80）建立一个 TCP 套接字连接。例如，http://www.oakcms.cn。

**2、发送 HTTP 请求**
通过 TCP 套接字，客户端向 Web 服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据 4 部分组成。

**3、服务器接受请求并返回 HTTP 响应**
Web 服务器解析请求，定位请求资源。服务器将资源复本写到 TCP 套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据 4 部分组成。

**4、释放连接 TCP 连接**
若 connection 模式为 close，则服务器主动关闭 TCP 连接，客户端被动关闭连接，释放 TCP 连接;若 connection 模式为 keep-alive，则该连接会保持一段时间，在该时间内可以继续接收请求;

**5、客户端浏览器解析HTML内容**
客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的 HTML 文档和文档的字符集。客户端浏览器读取响应数据 HTML ，根据 HTML 的语法对其进行格式化，并在浏览器窗口中显示。

例如：在浏览器地址栏键入 URL，按下回车之后会经历以下流程：

1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;

2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;

3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;

4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;

5、释放 TCP连接;

6、浏览器将该 html 文本并显示内容; 　

### 基于 HTTP 的功能追加协议

在最初建立 HTTP 标准规范的时候，制定者主要想把 HTTP 当作传输 HTML 文档的协议。但随着时代的发展，Web 的用途更加多样性，但由于 HTTP 协议上的限制和自身性能有限，导致目前的 Web 网站在性能上未必达到最优。

HTTP 的瓶颈如下所示：

- 一条连接上只可发送一个请求
- 请求只能从客户端开始。客户端不可以接收除响应以外的指令。
- 请求 / 响应首部未经压缩就发送。首部信息越多延迟越大
- 发送冗长的首部。每次互相发送相同的首部造成的浪费较多。
- 可任意选择数据压缩格式。非强制压缩发送。

#### Ajax 的解决方法

Ajax（Asynchronous JavaScript and XML，异步 JavaScript 与 XML 技术）是一种有效利用 JavaScript 和 DOM 的操作，以达到局部 Web 页面替换加载的异步通信手段。和以前的同步通信相比，由于它只更新一部分页面，响应中传输的数据量会因此而减少。

它的核心技术是名为 XMLHttpRequest 的 API，通过 JavaScript 脚本语言的调用就能和服务器进行 HTTP 通信。通过这种手段就可以实现从已加载完毕的 Web 页面上发起请求，只更新局部页面的操作。

但利用 Ajax 实时地从服务器获取内容，可能会导致大量请求产生。因此，Ajax 仍未解决 HTTP 协议本身存在的问题。

#### Comet 的解决方法

Comet 是在服务器有更新内容后直接给请求返回响应。是一种通过延迟应答，模拟实现服务器端向客户端推送的功能。

内容上虽然可以做大实时更新，但为了保留响应，一次连接的持续时间也变长了。期间为了维持连接，会消耗更多的资源，并且也未解决 HTTP 协议本身的问题。

#### SPDY

SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层和传输层之间通过**新加会话层的形式**运作，并且规定通信中使用 SSL 来提高安全性。

SPDY 给 HTTP 协议加入了额外的功能：

- **多路复用流**。通过单一的 TCP 连接，可以无限处理多个 HTTP 请求，并且所有请求在一条 TCP 连接上完成，提高了 TCP 的处理效率
- **赋予处理优先级**。
- **压缩响应首部**。
- **推送功能**。支持服务器主动向客户端推送数据的功能
- **服务器提示功能**。服务器可以主动提示客户端请求所需要的资源，避免不必要的请求。

但 SPDY 基本上只是将单个域名（IP 地址）的通信多路复用，所以当一个 Web 网站上使用多个域名下的资源，改善效果会受到限制。

SPDY 确实是一种可有效消除 HTTP 瓶颈的技术，但很多 Web 存在的问题并非仅仅是由 HTTP 瓶颈所导致。

#### WebSocket--使用浏览器进行全双工通信

利用 Ajax 和 Comet 技术进行通信可以提升 Web 的浏览速度，但问题在于通信若用 HTTP 协议，就无法彻底解决瓶颈问题。WebSocket 网络技术正是为解决这些问题而实现的一套新协议及 API。

WebSocket是建立在 HTTP 协议上，连接的发起方仍是客户端，但一旦建立 WebSocket 通信连接，任意一方都可以直接向对方发送报文。

其主要特点如下：

- **推送功能**
- **减少通信量**

为了实现 WebSocket 通信，在 HTTP 连接建立后，需要完成一次“握手”(Handshaking)的步骤，其中响应会返回状态码 101 Switching Protocols。

#### HTTP 2

HTTP/2 （原名HTTP/2.0）即超文本传输协议 2.0，是下一代 HTTP 协议。是由互联网工程任务组（IETF）的 Hypertext Transfer Protocol Bis (httpbis)工作小组进行开发。是自 1999 年 http1.1 发布后的首个更新。HTTP 2.0 在2013年8月进行首次合作共事性测试。**在开放互联网上HTTP 2.0 将只用于 https:// 网址，而 http:// 网址将继续使用 HTTP/1，目的是在开放互联网上增加使用加密技术，以提供强有力的保护去遏制主动攻击**。

在 HTTP/2 的第一版草案（对 SPDY 协议的复刻）中，新增的性能改进不仅包括 HTTP/1.1 中已有的多路复用，修复队头阻塞问题，允许设置设定请求优先级，还包含了一个头部压缩算法(HPACK)。此外，HTTP/2 采用了二进制而非明文来打包、传输客户端—服务器间的数据。其他新特性包括如下：

- **帧、消息、流和TCP连接** HTTP/2 与 SPDY 一样，将一个 TCP 连接分为若干个流（Stream），每个流中可以传输若干消息（Message），每个消息由若干最小的二进制帧（Frame）组成。这个举措在 SPDY 中的实践表明，相比 HTTP/1.1，新页面加载可以加快 11.81% 到 47.7%。
- **HPACK 算法** HPACK 算法是新引入 HTTP/2 的一个算法，用于对 HTTP 头部做压缩。
- **服务器推送** HTTP/2 引入了服务器推送，即服务端向客户端发送比客户端请求更多的数据。这允许服务器直接提供浏览器渲染页面所需资源，而无须浏览器在收到、解析页面后再提起一轮请求，节约了加载时间。

截至2015年末，主要的浏览器的最新版本已经支持HTTP/2这一协议。其中：

- Google Chrome、Mozilla Firefox、Microsoft Edge 和 Opera 已支持 HTTP/2，并默认启用。
- Internet Explorer 自 IE 11 开始支持 HTTP/2，并预设激活。

---

## 2. HTTP 消息结构

HTTP 是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。

一个 HTTP "客户端"是一个应用程序（Web 浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个 HTTP 的请求的目的。

一个 HTTP "服务器"同样也是一个应用程序（通常是一个 Web 服务，如 Apache Web 服务器或 IIS 服务器等），通过接收客户端的请求并向客户端发送 HTTP 响应数据。

HTTP 使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。

一旦建立连接后，数据消息就通过类似 Internet 邮件所使用的格式和多用途 Internet 邮件扩展（MIME）来传送。

### 请求消息

客户端发送一个 HTTP 请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。


![image](http://7xrluf.com1.z0.glb.clouddn.com/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF.png)

### 响应消息

HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。

![image](http://7xrluf.com1.z0.glb.clouddn.com/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E6%B6%88%E6%81%AF.jpg)


### 实例

下面实例是一点典型的使用 GET 来传递数据的实例：

客户端请求：


```
GET /hello.txt HTTP/1.1
User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
Host: www.example.com
Accept-Language: en, mi
```

服务端响应:


```
HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Server: Apache
Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
ETag: "34aa387-d-1568eb00"
Accept-Ranges: bytes
Content-Length: 51
Vary: Accept-Encoding
Content-Type: text/plain
```

输出结果：


```
Hello World! My payload includes a trailing CRLF.
```

### HTTP 首部字段

HTTP 首部字段主要分为以下四种字段：

- 通用首部字段
- 请求首部字段
- 响应首部字段
- 实体首部字段

另外，上述字段还可以根据是否缓存代理分为两个类型：

- 端到端首部
- 逐跳首部--包含8个字段
    - Connection
    - Keep-Alive
    - Proxy-Authenticate
    - Proxy-Authorization
    - Trailer
    - TE
    - Transfer-Encoding
    - Upgrade

#### 为 Cookie 服务的首部字段
- Set-Cookie：服务器开始管理客户端状态时，会事先告知各种信息
- Cookie：告知服务器，客户端想获得 HTTP 状态管理支持

#### 其他首部字段

HTTP 首部字段是可以拓展的，所以在 Web 服务器和浏览器应用上，会出现各种非标准的首部字段

- X-Frame-Options：属于 HTTP 响应首部，用于控制在其他 Web 网站的 Frame 标签内的显示问题，防止点击劫持（clickjacking）攻击
- X-XSS-Protection：属于 HTTP 响应首部，针对跨站脚本攻击（XSS)的一种对策，用于控制浏览器 XSS 防护机制的开关
- DNT（Do Not Track）：属于 HTTP 请求首部，用于拒绝被精准广告追踪的一种方法
- P3P：属于 HTTP 响应首部，通过利用 P3P(The Platform for Privacy Preferences，在线隐私偏好平台)技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。

### HTTP 状态码

HTTP 状态码是服务器的响应消息中第一行包含的，它是由三位数字和原因状语组成，例如 200 OK 表示请求成功，状态码总共分为5种类型，根据数字首位来区分，如下所示：

- 1XX，信息性状态码，接收的请求正在处理
- 2XX，成功状态码，请求正常处理完毕
    - 200 OK：客户端发送的请求被服务器正常处理
    - 204 No Content：服务器正常处理接收的请求，但返回响应报文没有任何实体的主体
    - 206 Partial Content：客户端采用范围请求的状态码
- 3XX，重定向状态码，需要进行附加操作以完成请求
    - 301 Moved Permanently：永久性重定向。表示请求的资源已被分配了新的 URI
    - 302 Found：临时性重定向。
    - 303 See Other：表示请求的资源存在另一个 URI，应使用 GET 方法定向获取请求的资源。
    - 304 Not Modified：发生了为满足条件的情况
    - 307 Temporary Redirect：临时重定向。与 302 Found 有相同的含义，但 307 不会从 POST 变成 GET
- 4XX，客户端错误状态码，服务器无法处理请求
    - 400 Bad Request：请求的报文存在语法错误
    - 401 Unauthorized：请求需要通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息
    - 403 Forbidden：对请求资源的访问被服务器拒绝了。
    - 404 Not Found：服务器上找不到请求的资源
- 5XX，服务器错误状态码，服务器处理请求出错
    - 500 Internal Server Error：表示服务器端在执行请求时发生错误。也可能是 Web 应用存在的 bug 或者某些临时的故障
    - 503 Service Unavailable：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求

